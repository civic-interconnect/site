{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Site","text":"<p>If you are not redirected, go to English.</p>"},{"location":"en/","title":"Project Documentation","text":"<p>Documentation for civic-interconnect.</p> <p>Use the navigation menu to explore available content.</p> <p>This home page will always be served at <code>/</code>.</p> <p>To learn more, visit the GitHub repository.</p>"},{"location":"en/DATA_SOURCES/","title":"External Data Sources Used in Civic Interconnect","text":"<p>This document lists datasets used during development, testing, and validation of the Civic Exchange Protocol (CEP), the Contextual Evidence and Explanations (CEE) layer, and associated adapters.</p> <p>All external datasets include provenance, licensing information, and machine- readable citations following the W3C PROV standard.</p>"},{"location":"en/DATA_SOURCES/#city-of-chicago-contracts-dataset","title":"City of Chicago \u2013 Contracts Dataset","text":"<p>URL: https://data.cityofchicago.org/Administration-Finance/Contracts/rsxa-ify5</p> <p>Publisher: City of Chicago, Department of Procurement Services</p> <p>License: Public Domain (Chicago Open Data Portal)</p> <p>Usage in CEP: This dataset is used for testing: - name normalization (EFS v1) - SNFEI cross-source entity identity resolution - adapter behavior for real-world procurement verticals - canonicalization stress tests</p> <p>Embedded JSON Citation Block: <pre><code>{\n  \"type\": \"dataset\",\n  \"title\": \"City of Chicago Contracts Dataset\",\n  \"publisher\": \"City of Chicago\",\n  \"url\": \"https://data.cityofchicago.org/Administration-Finance/Contracts/rsxa-ify5\",\n  \"license\": \"Public Domain (Chicago Open Data Portal)\",\n  \"retrievedAt\": \"2025-12-11T00:00:00Z\"\n}\n</code></pre></p> <p>PROV (YAML): <pre><code>entity:\n  chicago_contracts_dataset:\n    prov:type: \"prov:Entity\"\n    dct:title: \"City of Chicago Contracts Dataset\"\n    dct:publisher: \"City of Chicago\"\n    dct:identifier: \"https://data.cityofchicago.org/Administration-Finance/Contracts/rsxa-ify5\"\n    dct:license: \"Public Domain (Chicago Open Data Portal)\"\n\nagent:\n  city_of_chicago:\n    prov:type: \"prov:Agent\"\n    foaf:name: \"City of Chicago, Department of Procurement Services\"\n\nactivity:\n  retrieve_chicago_contracts_2025_12_11:\n    prov:type: \"prov:Activity\"\n    prov:startedAtTime: \"2025-12-11T00:00:00Z\"\n    prov:wasAssociatedWith: city_of_chicago\n    prov:used: chicago_contracts_dataset\n</code></pre></p>"},{"location":"en/DATA_SOURCES/#future-datasets","title":"Future Datasets","text":"<p>Add additional datasets used for CEP/CEE validation here with their: - citation information - license - provenance - JSON source descriptor  </p>"},{"location":"en/quick-start/","title":"Quick Start","text":"<p>The Civic Exchange Protocol (CEP) is an open, standards-driven framework for creating verifiable civic records with canonical identities, provenance, and interoperability across jurisdictions.</p> <p>This guide shows how to:</p> <ol> <li>Install CEP tools  </li> <li>Validate schemas  </li> <li>Generate example records  </li> <li>Build entities programmatically  </li> </ol>"},{"location":"en/quick-start/#1-install-the-cep-toolkit","title":"1. Install the CEP Toolkit","text":"<p>Install the CLI and Python API from PyPI:</p> <pre><code>uv pip install civic-interconnect\n</code></pre> <p>Or add to an existing environment:</p> <pre><code>pip install civic-interconnect\n</code></pre> <p>Confirm installation:</p> <pre><code>cx --help\n</code></pre>"},{"location":"en/quick-start/#2-validate-a-cep-record","title":"2. Validate a CEP Record","text":"<p>CEP ships with a JSON Schema validator:</p> <pre><code>cx validate path/to/my-entity.json\n</code></pre> <p>You may validate any record family:</p> <pre><code>cx validate --schema entity path/to/my-entity.json\ncx validate --schema relationship path/to/my-relationship.json\ncx validate --schema exchange path/to/my-exchange.json\n</code></pre> <p>Successful validation confirms:</p> <ul> <li>Schema compliance  </li> <li>Vocabulary references  </li> <li>Canonical field types  </li> <li>Envelope integrity  </li> </ul>"},{"location":"en/quick-start/#3-generate-example-data","title":"3. Generate Example Data","text":"<p>The CLI can generate examples for any directory under <code>examples/</code>:</p> <pre><code>cx generate-example examples/entity --overwrite\n</code></pre> <p>This produces three files per slice:</p> <ul> <li>01_raw_source.json \u2013 raw adapter input  </li> <li>02_normalized.json \u2013 normalized fields  </li> <li>03_canonical.json \u2013 canonical hash inputs  </li> <li>04_entity_record.json \u2013 final CEP EntityRecord  </li> </ul> <p>This is the best way to understand the transformation pipeline.</p>"},{"location":"en/quick-start/#4-build-an-entity-using-python","title":"4. Build an Entity Using Python","text":"<p>You can construct SNFEI values and full EntityRecords programmatically.</p> <pre><code>from civic_interconnect.cep.snfei import generate_snfei_detailed\nfrom civic_interconnect.cep.entity.api import build_entity_from_raw\n\nres = generate_snfei_detailed(\n    legal_name=\"City of Springfield\",\n    country_code=\"US\",\n    address=\"123 Lincoln Ave\",\n    registration_date=None,\n    lei=None,\n    sam_uei=None,\n)\n\nraw = {\n    \"jurisdictionIso\": \"US-MN\",\n    \"legalName\": \"City of Springfield\",\n    \"legalNameNormalized\": res[\"canonical\"][\"legalNameNormalized\"],\n    \"snfei\": res[\"snfei\"][\"value\"],\n    \"entityType\": \"municipality\",\n}\n\nentity = build_entity_from_raw(raw)\nprint(entity[\"verifiableId\"])\n</code></pre> <p>Rust bindings are required and contain the core logic, CEP uses them automatically.</p>"},{"location":"en/quick-start/#5-next-steps","title":"5. Next Steps","text":"<ul> <li>Learn how SNFEI canonical identities work at <code>/en/reference/snfei.md</code></li> <li>Understand normalization at <code>/en/concepts/normalization.md</code></li> <li>Explore record envelopes and provenance at <code>/en/implementation/record-envelopes.md</code></li> <li>Explore schemas at <code>/en/schemas.md</code></li> </ul> <p>CEP aims to make civic data verifiable, interoperable, and future-proof with minimal integration overhead.</p> <p>Welcome to the network of connected civic data!</p>"},{"location":"en/schemas/","title":"Civic Interconnect Schemas","text":"Schema Description cep.entity.schema.json Entity records cep.entity.identifier-scheme.schema.json Identifier scheme metadata cep.relationship.schema.json Relationship records cep.exchange.schema.json Exchange records cep.record-envelope.schema.json Core envelope shared by all record families cep.vocabulary.schema.json Vocabulary definition meta-schema cep.ctag.schema.json Per-post tagging model README.md Schema overview and documentation"},{"location":"en/schemas/#schema-and-vocabulary-versions","title":"Schema and Vocabulary Versions","text":"<p>Schemas are expected to change less often than vocabularies and the versioning is handled differently.</p> <ul> <li>Schema URIs are found from the file names <code>schemas/core/cep.entity.schema.json</code>, etc. </li> <li>Schemas are unversioned at the path, and the <code>schemaVersion</code> field provides the version.</li> <li>Vocabulary URIs are found in <code>vocabulary/&lt;name&gt;.v1.0.0.json#&lt;code&gt;</code>.</li> </ul>"},{"location":"en/concepts/interoperability/","title":"Interoperability","text":"<p>CEP is designed to integrate with: </p> <ul> <li>Popolo - the entity + political relationships backbone of nearly every open civics project worldwide (OCD, OpenStates, etc.) includes models for Person, Organization, Membership,  Post / Role, Area, Event, Motion / Vote, Legislative Activity and works for elected officials, models boards, committees, councils, includes membership graph.</li> <li>Open Civic Data</li> <li>Open Contracting Data Standard (OCDS) - international standard for public procurement, contracts, tenders, awards, suppliers, implementation and milestone tracking.</li> <li>Schema.org - includes Organization, Person, Place, GovernmentOrganization, Grant, MonetaryGrant,  Legislation, VoteAction and enables interoperability with Google datasets, machine readability.</li> <li>Financial Taxonomies (XBRL) - good for financial reporting, auditing, interoperability with Treasury and state finance systems</li> <li>W3C PROV - good for academics and auditors, PROV guides revision chains, attestation blocks, canonical timestamps, and hash-based integrity. CEP attestation maps to PROV wasGeneratedBy, wasAttributedTo, wasDerivedFrom and CEP previousRecordHash maps to PROV wasRevisionOf.</li> <li>Open Referral Human Services Data Specification (HSDS) - has Organization, Location, Service, Funding - enables connecting public funding to outcomes</li> <li>Financial Industry Business Ontology (FIBO) - map to loan-agreement, grant-award (loosely), subsidiary.</li> </ul>"},{"location":"en/concepts/interoperability/#cep-concept-mapping-table","title":"CEP Concept Mapping Table","text":"CEP Concept CEP Term / Field CEP Vocabulary / Schema External Standard External Concept / Class / Field Mapping Type Notes Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Popolo <code>Organization</code> exactMatch Government bodies (legislatures, councils, agencies). Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> OCD <code>ocd-jurisdiction</code> exactMatch Use in <code>identifiers.additionalSchemes</code> with OCD jurisdiction IDs. Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Schema.org <code>GovernmentOrganization</code> exactMatch For web/SEO and generic data consumers. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> OCD <code>ocd-division</code> + <code>ocd-jurisdiction</code> (school districts) broadMatch Division/jurisdiction pair identifies school districts. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> Schema.org <code>EducationalOrganization</code> / <code>SchoolDistrict</code> (where available) exactMatch For education analytics and public-facing data. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Popolo <code>Organization</code> with classification <code>nonprofit</code> broadMatch Nonprofits providing services, fiscal sponsors, etc. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Schema.org <code>NGO</code> / <code>Organization</code> relatedMatch Web-compatible representation of nonprofits. Entity (organization) <code>entityTypeUri = #vendor</code> <code>entity-type.json</code> OCDS <code>Party</code> with role <code>supplier</code> exactMatch Contractors / vendors in procurement. Entity (natural person) <code>entityTypeUri = #natural-person</code> <code>entity-type.json</code> Popolo <code>Person</code> exactMatch Politicians, officials, natural-person donors, etc. Entity (natural person) <code>entityTypeUri = #elected-official</code> <code>entity-type.json</code> Popolo <code>Person</code> + <code>Membership</code> in <code>Organization</code> exactMatch Derived from Popolo membership in a legislature / council. Entity (natural person) <code>entityTypeUri = #natural-person</code> / <code>#elected-official</code> <code>entity-type.json</code> Schema.org <code>Person</code> exactMatch Generic consumer-friendly alignment. Entity (division) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division/...</code> exactMatch Political geography for school districts, counties, states, etc. Entity (jurisdiction) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-jurisdiction/...</code> exactMatch Governing bodies over divisions. Entity (organization) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-organization/...</code> exactMatch Committees, councils, agencies, boards. Entity (person) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-person/...</code> exactMatch People in OCD-compatible civic graphs. Entity (financial) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI ISO 17442 Legal Entity Identifier exactMatch Global financial identity for entities in financial transactions. Entity (federal) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov Unique Entity Identifier exactMatch U.S. federal financial identity for entities. Entity (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) Hash-based Structured Non-Fungible Entity Identifier newConcept Bridges UEI/LEI to local civic entities; open-source identifier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> exactMatch Prime contract between government and supplier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> USAspending <code>contract</code> (glossary) exactMatch Alignment with USASpending contract awards. Relationship (subcontract) <code>relationshipTypeUri = #subcontract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> linked via <code>relatedProcesses</code> broadMatch Subcontracts under a prime contract. Relationship (grant) <code>relationshipTypeUri = #grant-award</code> <code>relationship-type.json</code> USAspending <code>grant</code> (glossary) exactMatch Federal grants / assistance awards. Relationship (subgrant) <code>relationshipTypeUri = #subgrant</code> <code>relationship-type.json</code> OCDS <code>Award</code> + <code>Implementation.transactions</code> for subawards broadMatch Pass-through grants from state to local entities. Relationship (coop agrmt) <code>relationshipTypeUri = #cooperative-agreement</code> <code>relationship-type.json</code> USAspending <code>cooperative agreement</code> exactMatch Cooperative federal assistance relationships. Relationship (interagency) <code>relationshipTypeUri = #interagency-agreement</code> <code>relationship-type.json</code> OCDS <code>Contract</code> or <code>Agreement</code> between government parties relatedMatch Transfer agreements between agencies. Relationship (MOU) <code>relationshipTypeUri = #memorandum-of-understanding</code> <code>relationship-type.json</code> Popolo <code>Membership</code> / <code>Organization</code> with informal cooperation relatedMatch Non-binding but structured relationships. Relationship (fiscal spon) <code>relationshipTypeUri = #fiscal-sponsorship</code> <code>relationship-type.json</code> HSDS <code>Funding</code> / <code>Service</code> provider/host relationship relatedMatch Connects projects to 501(c)(3) entities. Relationship (board) <code>relationshipTypeUri = #board-membership</code> <code>relationship-type.json</code> Popolo <code>Membership</code> (person \u2194 organization, role = board member) exactMatch Governance relationships. Relationship (employment) <code>relationshipTypeUri = #employment</code> <code>relationship-type.json</code> Popolo <code>Membership</code> or <code>Post</code> with classification <code>employment</code> exactMatch Staff roles in agencies, schools, vendors. Relationship (consulting) <code>relationshipTypeUri = #consulting-engagement</code> <code>relationship-type.json</code> Popolo <code>Membership</code> with classification <code>consultant</code> relatedMatch Non-employee professional services. Relationship (subsidiary) <code>relationshipTypeUri = #subsidiary</code> <code>relationship-type.json</code> Schema.org <code>subOrganization</code> relatedMatch Corporate ownership within civic vendor trees. Relationship (joint ven.) <code>relationshipTypeUri = #joint-venture</code> <code>relationship-type.json</code> FIBO Joint venture relationship relatedMatch Optional mapping for advanced financial/corporate semantics. Relationship (reg. reg.) <code>relationshipTypeUri = #regulatory-registration</code> <code>relationship-type.json</code> Schema.org <code>GovernmentOrganization</code> + <code>registration</code>-related properties relatedMatch Entities registered with regulatory bodies. Relationship (loan) <code>relationshipTypeUri = #loan-agreement</code> <code>relationship-type.json</code> FIBO Loan contract exactMatch For loans, bond-like instruments, and revolving credit. Relationship (bill-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Bill</code> object relatedMatch Relationship authorized or shaped by a bill. Relationship (vote-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Vote</code> object relatedMatch Relationship activated/approved by a vote. Relationship (event-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Event</code> object relatedMatch Relationship linked to hearings, meetings, signings. Exchange (grant) <code>exchangeTypeUri = #grant-disbursement</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type grant disbursement exactMatch Payment of grant funds under a grant-award relationship. Exchange (contract fee) <code>exchangeTypeUri = #contract-fee-payment</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type payment exactMatch Invoice payments under contracts. Exchange (subaward) <code>exchangeTypeUri = #subgrant-disbursement</code> <code>exchange-type.json</code> USAspending Subaward transactions exactMatch Pass-through disbursements to subrecipients. Exchange (donation) <code>exchangeTypeUri = #campaign-contribution</code> <code>exchange-type.json</code> Popolo / DIME Contribution records mapped to <code>Person</code> / <code>Organization</code> donors/recipients relatedMatch Campaign finance contributions tied into CEP graph. Exchange (in-kind) <code>value.valueTypeUri = #in-kind</code> <code>value-type.json</code> Schema.org <code>Offer</code> / <code>Grant</code> with non-monetary value relatedMatch Non-monetary goods/services tracked in CEP. Exchange (service-hours) <code>value.valueTypeUri = #service-hours</code> <code>value-type.json</code> HSDS <code>Service</code> + time-based contributions relatedMatch Volunteer or staff time as value. Exchange (categorization) <code>categorization.naicsCode</code> <code>cep.exchange.schema.json</code> NAICS NAICS industry codes exactMatch Standard economic activity classification for exchanges. Exchange (categorization) <code>categorization.cfdaNumber</code> <code>cep.exchange.schema.json</code> CFDA / Assistance CFDA / Assistance Listing number exactMatch Links exchanges to federal assistance programs. Exchange (categorization) <code>categorization.gtasAccountCode</code> <code>cep.exchange.schema.json</code> GTAS Treasury Account Symbol exactMatch Aligns exchanges to Treasury reporting accounts. Exchange (source) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCDS <code>Release</code>, <code>Award</code>, <code>Contract</code>, <code>Implementation.transactions</code> relatedMatch Exchange derived from procurement data. Exchange (bill/vote) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCD <code>Bill</code>, <code>Vote</code>, <code>Event</code> relatedMatch Funding events tied to legislative activity. Value (monetary) <code>value.valueTypeUri = #monetary</code> <code>value-type.json</code> XBRL Monetary item types (e.g., <code>monetaryItemType</code>) exactMatch Monetary amounts aligned with financial reporting taxonomies. Value (monetary) <code>value.amount</code>, <code>value.currencyCode</code> <code>cep.exchange.schema.json</code> XBRL <code>xbrli:monetaryItemType</code>, ISO 4217 exactMatch Strictly typed monetary values. Value (provisioning) <code>valueTypeUri = #service-hours</code> / <code>#in-kind</code> <code>value-type.json</code> HSDS <code>Service</code> value dimensions relatedMatch For human services and community programs. Provenance (entity) <code>attestation</code> block on Entity <code>cep.entity.schema.json</code> W3C PROV <code>prov:Entity</code>, <code>prov:wasGeneratedBy</code>, <code>prov:wasAttributedTo</code> exactMatch Entity record as a PROV entity with associated agent/activity. Provenance (relationship) <code>attestation</code> block on Relationship <code>cep.relationship.schema.json</code> W3C PROV Same as above exactMatch Relationship record provenance in PROV terms. Provenance (exchange) <code>attestation</code> block on Exchange <code>cep.exchange.schema.json</code> W3C PROV Same as above exactMatch Exchange record provenance. Provenance (revision) <code>previousRecordHash</code>, <code>revisionNumber</code> all CEP core schemas W3C PROV <code>prov:wasRevisionOf</code>, <code>prov:qualifiedRevision</code> exactMatch Immutable revision chains expressed via hashes and monotone revisions. Provenance (hash) Canonical string + SHA-256 hash (SSOT) implementation / spec W3C PROV <code>prov:generatedAtTime</code>, <code>prov:wasDerivedFrom</code> relatedMatch Hash as integrity proof supporting PROV-compatible derivation chains. IDs (UEI) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov UEI exactMatch Federal identity. IDs (LEI) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI LEI exactMatch Global financial identity. IDs (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) SNFEI newConcept Open, recomputable sub-federal ID bridging UEI/LEI and local civic entities. IDs (OCD) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division</code>, <code>ocd-jurisdiction</code>, <code>ocd-organization</code>, <code>ocd-person</code> exactMatch Primary bridge to the Open Civic Data topology. IDs (OCDS) <code>identifiers.additionalSchemes</code> on Entity/Relationship <code>cep.entity/relationship</code> OCDS <code>Parties</code>, <code>Award.id</code>, <code>Contract.id</code> relatedMatch Tie CEP entities/relationships back to OCDS releases. IDs (Popolo) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> Popolo <code>Person.id</code>, <code>Organization.id</code> relatedMatch Where Popolo IDs exist separately from OCD IDs."},{"location":"en/concepts/interoperability/#cep-concept-mapping-table-by-schema","title":"CEP Concept Mapping Table (by Schema)","text":"CEP Concept / Field External Standard External Concept / ID / Class Mapping Type Suggested <code>externalUri</code> / <code>schemeUri</code> example Notes Entity (general civic entity) Popolo <code>Person</code>, <code>Organization</code> broadMatch <code>http://www.popoloproject.com/specs/person.html</code>, <code>http://www.popoloproject.com/specs/organization.html</code> CEP <code>entity</code> covers both persons and orgs; Popolo separates. <code>entityTypeUri</code> <code>#natural-person</code> Popolo <code>Person</code> exactMatch <code>http://www.popoloproject.com/specs/person.html</code> For individuals (candidates, officials, donors). <code>entityTypeUri</code> <code>#organization</code> Popolo <code>Organization</code> exactMatch <code>http://www.popoloproject.com/specs/organization.html</code> Base org type, parent of more specific government / nonprofit types. <code>entityTypeUri</code> <code>#government-jurisdiction</code> Popolo/OCD Popolo <code>Organization</code> + OCD <code>jurisdiction</code> relatedMatch <code>https://opencivicdata.org/id/jurisdiction</code> A governing body; mix of org and jurisdiction. <code>identifiers.additionalSchemes</code> (division) OCD <code>ocd-division/*</code> exactMatch <code>https://opencivicdata.org/id/division</code> Store OCD division IDs as <code>schemeUri = \"https://opencivicdata.org/id/division\"</code>. <code>identifiers.additionalSchemes</code> (jurisdiction) OCD <code>ocd-jurisdiction/*</code> exactMatch <code>https://opencivicdata.org/id/jurisdiction</code> Store OCD jurisdiction IDs. <code>identifiers.additionalSchemes</code> (person) OCD / Popolo <code>ocd-person/*</code> (Popolo person) exactMatch <code>https://opencivicdata.org/id/person</code> Link CEP entity to OCD/Popolo person IDs. <code>identifiers.additionalSchemes</code> (organization) OCD / Popolo <code>ocd-organization/*</code> exactMatch <code>https://opencivicdata.org/id/organization</code> Link CEP entity to OCD/Popolo org IDs. <code>identifiers.lei</code> leif / LEI <code>LEI</code> (ISO 17442 Legal Entity Identifier) exactMatch <code>https://www.gleif.org/en/about-lei/introducing-the-legal-entity-identifier-lei</code> Already in schema; key for global finance interoperability. <code>identifiers.samUei</code> US Federal UEI (SAM.gov Unique Entity Identifier) exactMatch <code>https://www.sam.gov/</code> Tier 2 identity in our stack. <code>identifiers.additionalSchemes</code> (OCDS party) OCDS <code>parties.identifier.id</code> relatedMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Use for suppliers / buyers in procurement records. <code>entityTypeUri</code> <code>#supplier</code> / <code>#contractor</code> OCDS <code>Organization</code> with role <code>supplier</code> / <code>tenderer</code> exactMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Straight mapping for vendors. <code>entityTypeUri</code> <code>#school-district</code> Schema.org <code>SchoolDistrict</code> (subtype of <code>EducationalOrganization</code>) relatedMatch <code>https://schema.org/SchoolDistrict</code> For education equity analytics. <code>entityTypeUri</code> <code>#government-agency</code> Schema.org <code>GovernmentOrganization</code> exactMatch <code>https://schema.org/GovernmentOrganization</code> For agencies at any level. Relationship (legal / functional relationships) Popolo <code>Membership</code>, <code>Post</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> CEP Relationship is more general; includes contracts, grants, etc. <code>relationshipTypeUri</code> <code>#board-membership</code> Popolo <code>Membership</code> exactMatch <code>http://www.popoloproject.com/specs/membership.html</code> Board membership of a person in an org. <code>relationshipTypeUri</code> <code>#employment</code> Popolo <code>Membership</code> (with <code>post</code> / <code>role</code>) broadMatch <code>http://www.popoloproject.com/specs/membership.html</code> Employment is a constrained membership. <code>relationshipTypeUri</code> <code>#consulting-engagement</code> Popolo <code>Membership</code> or <code>ContactDetail</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> Less formal, non-employee service relationship. <code>relationshipTypeUri</code> <code>#prime-contract</code> OCDS <code>Contract</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> CEP Relationship for a prime contract matches OCDS Contract. <code>relationshipTypeUri</code> <code>#subcontract</code> OCDS <code>Contract</code> with <code>relatedProcesses</code> / <code>relatedLots</code> narrowMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> Subcontracts are contracts linked to a parent award. <code>relationshipTypeUri</code> <code>#grant-award</code> OCDS <code>Award</code> relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#award</code> OCDS is procurement-focused; grants are adjacent. <code>relationshipTypeUri</code> <code>#cooperative-agreement</code> OCDS <code>Award</code> or <code>Contract</code> (context-specific) relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/</code> Map conceptually to awarded agreements. <code>relationshipTypeUri</code> <code>#loan-agreement</code> FIBO <code>LoanAgreement</code> exactMatch <code>https://spec.edmcouncil.org/fibo/ontology/FBC/DebtAndEquities/Debt/LoanAgreement</code> Optional FIBO mapping; useful for financial instruments. <code>relationshipTypeUri</code> <code>#subsidiary</code> Schema.org <code>subOrganization</code> relatedMatch <code>https://schema.org/subOrganization</code> See vocab.mappings. <code>relationshipTypeUri</code> <code>#joint-venture</code> Schema.org <code>Organization</code> with <code>memberOf</code> relatedMatch <code>https://schema.org/Organization</code> Joint ventures as special multi-party orgs. <code>relationshipTypeUri</code> <code>#regulatory-registration</code> Schema.org <code>GovernmentOrganization</code> / <code>Service</code> relatedMatch <code>https://schema.org/GovernmentOrganization</code> Registration with a regulator. <code>relationshipTypeUri</code> <code>#fiscal-sponsorship</code> HSDS / Nonprofit HSDS <code>Funding</code> or <code>Service</code> relatedMatch <code>https://github.com/openreferral/specification</code> For nonprofit fiscal sponsor relationships. Exchange (value transfer events) OCDS <code>Implementation.transactions[]</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#implementation</code> CEP Exchange is very close to OCDS transaction-level data. <code>exchangeTypeUri</code> <code>#grant-disbursement</code> Schema.org <code>MonetaryGrant</code> exactMatch <code>https://schema.org/MonetaryGrant</code> Core pattern for education &amp; campaign finance. <code>exchangeTypeUri</code> <code>#contract-fee-payment</code> Schema.org <code>Payment</code> / <code>Invoice</code> relatedMatch <code>https://schema.org/Invoice</code> Payment for contracted services. <code>exchangeTypeUri</code> <code>#donation</code> (if defined) Schema.org <code>DonateAction</code> relatedMatch <code>https://schema.org/DonateAction</code> Campaign or charitable donations. <code>exchangeTypeUri</code> <code>#loan-disbursement</code> FIBO <code>LoanPrincipalPayment</code> relatedMatch FIBO debt concepts More detailed financial modeling if needed. Value &amp; Categorization XBRL GAAP / GRT financial elements exactMatch e.g. <code>http://xbrl.us/us-gaap/2024-01-31#RevenueRecognition</code> Map CEP <code>categorization</code> fields to XBRL when possible. <code>value.currencyCode</code> ISO 4217 Currency codes exactMatch <code>https://www.iso.org/iso-4217-currency-codes.html</code> Already enforced by regex. <code>categorization.naicsCode</code> NAICS NAICS activity code exactMatch <code>https://www.census.gov/naics/</code> Already included in schema. <code>categorization.cfdaNumber</code> Assistance List CFDA / Assistance Listing number exactMatch <code>https://sam.gov/content/assistance-listing</code> For federal assistance programs. <code>categorization.gtasAccountCode</code> US GTAS Treasury Account Symbol (TAS) exactMatch <code>https://fiscal.treasury.gov/gtas/</code> Connects to federal reporting. Provenance &amp; Attestation W3C PROV <code>Entity</code>, <code>Activity</code>, <code>Agent</code>, <code>wasGeneratedBy</code>, <code>wasAttributedTo</code>, etc. relatedMatch <code>https://www.w3.org/TR/prov-o/</code> CEP is PROV-aligned but more specialized. <code>attestation.attestorId</code> W3C PROV <code>Agent</code> / <code>prov:wasAttributedTo</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasAttributedTo</code> The attesting node is the Agent. <code>attestation.attestationTimestamp</code> W3C PROV <code>generatedAtTime</code> exactMatch <code>https://www.w3.org/TR/prov-o/#generatedAtTime</code> When the record (Entity) was generated. <code>previousRecordHash</code> W3C PROV <code>wasRevisionOf</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasRevisionOf</code> Revision chain between CEP records. <code>provenanceChain.fundingChainTag</code> W3C PROV <code>wasDerivedFrom</code> chain relatedMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Human-readable representation of a PROV derivation path. <code>provenanceChain.parentExchangeId</code> W3C PROV <code>wasDerivedFrom</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Parent exchange is the immediate predecessor in the flow. Events, Bills, Votes OCD / Popolo <code>Bill</code>, <code>VoteEvent</code>, <code>Event</code> relatedMatch <code>https://opencivicdata.org/specs/</code> Linked via <code>sourceReferences</code>. <code>sourceReferences</code> (bill) OCD <code>ocd-bill/*</code> exactMatch <code>https://opencivicdata.org/id/bill</code> For authorizing legislation. <code>sourceReferences</code> (vote) OCD / Popolo <code>ocd-vote/*</code> or Popolo <code>VoteEvent</code> exactMatch <code>https://opencivicdata.org/id/vote</code> For authorization votes. <code>sourceReferences</code> (event) OCD / Popolo <code>Event</code> exactMatch <code>https://opencivicdata.org/id/event</code> Meetings, hearings tied to relationships or exchanges. Human Services / Programs (optional) HSDS <code>Service</code>, <code>Organization</code>, <code>Funding</code> relatedMatch <code>https://github.com/openreferral/specification</code> For social services and community programs. <code>entityTypeUri</code> <code>#service-provider</code> HSDS <code>Organization</code> exactMatch <code>https://github.com/openreferral/specification</code> For agencies and nonprofits providing services. <code>relationshipTypeUri</code> <code>#service-delivery-agreement</code> (future) HSDS <code>Service</code> / <code>Funding</code> relatedMatch HSDS docs If added."},{"location":"en/concepts/interoperability/#vocabulary-notes","title":"Vocabulary Notes","text":"<p>prime-contract</p> <ul> <li>USAspending contract is a close conceptual match.</li> <li>OCDS contract is the canonical public procurement concept, so exactMatch.</li> </ul> <p>subcontract</p> <ul> <li>OCDS does not have a first-class subcontract object, but it is conceptually a specialized contract under a main award, so narrowMatch.</li> </ul> <p>grant-award</p> <ul> <li>USAspending grant is a direct match to federal grants.</li> <li>OCDS award is broader (covers procurements and grants), so relatedMatch.</li> <li>Schema.org MonetaryGrant is almost exactly, so exactMatch.</li> </ul> <p>loan-agreement</p> <ul> <li>FIBO Contracts and Loans ontologies give similar semantic neighborhood but more general, so relatedMatch.</li> </ul> <p>subsidiary</p> <ul> <li>Schema.org subOrganization is close but not strictly legal-definition match, so relatedMatch.</li> <li>FIBO Subsidiary is semantically close but in financial-industry framing; so relatedMatch.</li> </ul> <p>board-membership and employment</p> <ul> <li>Both are specializations of Popolo Membership (person\u2013organization relationship with roles and time-bounds), so narrowMatch.</li> </ul>"},{"location":"en/concepts/normalization/","title":"Normalization","text":"<p>Normalization is the first transformation step in the CEP pipeline. Its purpose is to convert raw, heterogeneous civic data into a consistent structure before canonicalization and hashing.</p> <p>In practice there are two layers:</p> <ul> <li>Adapter-level normalization - local, jurisdiction-aware cleaning and mapping from raw sources.</li> <li>Core normalization - a small, international, script-preserving pass implemented in the CEP core (Rust), applied just before SNFEI hashing.</li> </ul> <p>This separation ensures:</p> <ul> <li>Adapters can reflect local domain knowledge and messy source quirks</li> <li>Core normalization remains stable and global across all jurisdictions</li> <li>Normalization rules can evolve without breaking the hash function, as long as the core contract is respected</li> </ul>"},{"location":"en/concepts/normalization/#1-goals-of-normalization","title":"1. Goals of Normalization","text":"<p>Normalization should:</p> <ul> <li>Produce deterministic strings (same input \u2192 same normalized form)</li> <li>Ensure stable Unicode handling across scripts</li> <li>Provide predictable address strings for hashing</li> <li>Remove noise (punctuation, obvious boilerplate) without erasing meaning</li> <li>Apply jurisdiction-specific expansions via configuration, not ad-hoc code</li> </ul> <p>Normalization must not:</p> <ul> <li>Guess or infer missing values</li> <li>Perform record linkage or entity resolution</li> <li>Translate between languages</li> <li>Destroy information from non-Latin scripts just to satisfy ASCII-only constraints</li> </ul> <p>Anything that changes semantic meaning or crosses those boundaries belongs outside the canonical SNFEI path.</p>"},{"location":"en/concepts/normalization/#2-core-normalization-pipeline-international-policy","title":"2. Core Normalization Pipeline (International Policy)","text":"<p>The CEP core defines a script-preserving normalization policy used to build canonical inputs for SNFEI. Adapters may do extra work, but they must not contradict this core behavior.</p> <p>At a high level, core normalization does:</p> <ol> <li>Unicode normalization and case folding  </li> <li>Punctuation and spacing cleanup  </li> <li>Safe abbreviation expansion  </li> <li>Optional stop-word removal (language-aware)  </li> <li>Address cleanup for hashing</li> </ol>"},{"location":"en/concepts/normalization/#21-unicode-normalization-and-case-folding","title":"2.1 Unicode Normalization and Case Folding","text":"<p>Core normalization applies Unicode normalization and converts text to a stable lowercase form. </p> <p>We use Normalization Form Compatibility Decomposition (NFKD) for the SNFEI canonicalization path.</p> <p>Understanding NFD vs. NFKD</p> Form Full Name Effect on Characters Why We Use NFKD NFD Normalization Form Decomposition Separates base characters from combining marks/diacritics. Preserves too much semantic variation. For example, it would treat compatibility characters differently from their base equivalents. NFKD Normalization Form Compatibility Decomposition Separates base characters,  and replaces compatibility characters (e.g.,  ligatures, Roman numerals) with their best plain text equivalent. Addresses Entity Resolution. Compatibility characters often arise from rendering/typography and should be treated as equivalent for identity hashing (e.g., the KC in NFKC is too strict, but the KD in NFKD is perfect for eliminating visual noise). <p>The Core Process</p> <ul> <li>Apply NFKD: The input string is converted to NFKD. This replaces ligatures and compatibility characters with their basic constituent letters.</li> <li>Strip combining marks where safe (\u00e9 \u2192 e, \u00f1 \u2192 n, \u00f6 \u2192 o) for Latin-based scripts.</li> <li>Preserve underlying letters in all scripts (Greek, Cyrillic, Han, Arabic, etc.).</li> <li>Apply lowercase / casefolding to get a consistent case-insensitive representation.</li> </ul> <p>Examples:</p> <ul> <li><code>\"Soci\u00e9t\u00e9 G\u00e9n\u00e9rale\"</code> \u2192 <code>\"societe generale\"</code> </li> <li><code>\"\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae \u0395\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b1 \u0394\u03b5\u03b4\u03bf\u03bc\u03ad\u03bd\u03c9\u03bd\"</code> \u2192 a lowercased Greek string with accents normalized, but still in Greek, not dropped or transliterated to ASCII.</li> </ul> <p>Key property: Core normalization uses NFKD because it is the most aggressive form of decomposition that remains script-preserving (i.e., it doesn't try to turn Arabic into ASCII) while ensuring maximum equivalency for hashing identifiers, making two visually distinct inputs (due to font/encoding issues) hash to the same canonical ID.</p>"},{"location":"en/concepts/normalization/#22-punctuation-whitespace","title":"2.2 Punctuation &amp; Whitespace","text":"<p>All scripts share a common punctuation/whitespace policy:</p> <ul> <li>Replace punctuation (commas, periods, quotes, dashes, etc.) with spaces.</li> <li>Remove control characters.</li> <li>Collapse runs of whitespace to a single space.</li> <li>Trim leading/trailing spaces.</li> </ul> <p>Examples:</p> <ul> <li><code>\"City of Springfield, Inc.\"</code> \u2192 <code>\"city of springfield inc\"</code> </li> <li><code>\"123 N. Main St., Suite 400\"</code> (before abbreviation expansion) \u2192 <code>\"123 n main st suite 400\"</code></li> </ul>"},{"location":"en/concepts/normalization/#23-abbreviation-expansion-language-region-aware","title":"2.3 Abbreviation Expansion (Language- &amp; Region-Aware)","text":"<p>Abbreviations are expanded only where we have explicit rules. Core provides a Latin-focused, international set; jurisdictions can add overlays (e.g. <code>us/mn.yaml</code>, <code>us/ma.yaml</code>).</p> <p>Examples of core expansions:</p> <ul> <li>Legal forms:</li> <li><code>\"inc\"</code>, <code>\"inc.\"</code> \u2192 <code>\"incorporated\"</code></li> <li><code>\"corp\"</code>, <code>\"corp.\"</code> \u2192 <code>\"corporation\"</code></li> <li><code>\"gmbh\"</code> \u2192 <code>\"gesellschaft mit beschrankter haftung\"</code></li> <li><code>\"sa\"</code>, <code>\"s.a.\"</code> \u2192 <code>\"sociedad anonima\"</code> (by explicit rule)</li> <li>Organizational abbreviations:</li> <li><code>\"sch\"</code> \u2192 <code>\"school\"</code></li> <li><code>\"dist\"</code> \u2192 <code>\"district\"</code></li> <li><code>\"univ\"</code> \u2192 <code>\"university\"</code></li> </ul> <p>Address expansions (core US examples):</p> <ul> <li><code>\"st\"</code>, <code>\"st.\"</code> \u2192 <code>\"street\"</code></li> <li><code>\"ave\"</code>, <code>\"ave.\"</code> \u2192 <code>\"avenue\"</code></li> <li><code>\"n\"</code>, <code>\"n.\"</code> \u2192 <code>\"north\"</code></li> <li><code>\"sw\"</code> \u2192 <code>\"southwest\"</code></li> </ul> <p>For scripts outside that vocabulary, no attempt is made to transliterate or guess expansions; the text is left as cleaned lowercased Unicode.</p>"},{"location":"en/concepts/normalization/#24-stop-word-removal","title":"2.4 Stop-Word Removal","text":"<p>Stop words are used cautiously and are language-aware:</p> <ul> <li>Core defines a small English set: <code>\"the\"</code>, <code>\"of\"</code>, <code>\"and\"</code>, <code>\"for\"</code>, <code>\"in\"</code>, etc.</li> <li>They may be removed after expansion and punctuation cleanup.</li> <li>For names beginning with a stop word, behavior can be configured (e.g. preserve <code>\"the\"</code> at the start vs. drop it).</li> </ul> <p>Example (English):</p> <ul> <li><code>\"The City of Springfield\"</code> \u2192 <code>\"city springfield\"</code></li> </ul> <p>For non-English scripts, stop-word lists must be defined explicitly; otherwise, core does not silently drop tokens.</p>"},{"location":"en/concepts/normalization/#25-address-cleanup-for-hashing","title":"2.5 Address Cleanup for Hashing","text":"<p>For SNFEI hashing, addresses are normalized into a minimal, stable form:</p> <ul> <li>Lowercase + Unicode normalization as above.</li> <li>Remove secondary unit designators (apt, suite, floor, room, etc.).</li> <li>Remove punctuation and collapse whitespace.</li> <li>Expand postal abbreviations (US: <code>st</code> \u2192 <code>street</code>, <code>rd</code> \u2192 <code>road</code>, directionals, etc.).</li> <li>Trim final result; empty or near-empty addresses become <code>None</code> in canonical form.</li> </ul> <p>Example (US):</p> <ul> <li>Raw: <code>\"123 N. Main St., Suite 400\"</code> </li> <li>Normalized: <code>\"123 north main street\"</code></li> </ul>"},{"location":"en/concepts/normalization/#3-canonical-input-shape","title":"3. Canonical Input Shape","text":"<p>Core normalization produces a canonical input struct that feeds SNFEI hashing. Conceptually:</p> <pre><code>{\n  \"legalNameNormalized\": \"springfield public schools\",\n  \"addressNormalized\": \"123 north main street\",\n  \"countryCode\": \"US\",\n  \"registrationDate\": \"1985-01-15\"\n}\n</code></pre> <p>The canonical hash string is then built in a fixed order, e.g.:</p> <p><code>springfield public schools|123 north main street|US|1985-01-15</code></p> <p>Empty/unknown fields are represented as empty strings in the hash preimage, but stored as <code>null</code> / omitted in the JSON representation.</p>"},{"location":"en/concepts/normalization/#4-example-from-raw-to-normalized","title":"4. Example: From Raw to Normalized","text":"<p>Raw: <pre><code>{\n  \"legalName\": \"City of Springfield Unified Sch. Dist., Inc.\",\n  \"address\": \"123 N. Main St., Suite 400\",\n  \"countryCode\": \"US\",\n  \"jurisdictionIso\": \"US-IL\",\n  \"registrationDate\": \"01/15/1985\"\n}\n</code></pre></p> <p>Core-normalized canonical input:</p> <pre><code>{\n  \"legalNameNormalized\": \"city springfield unified school district incorporated\",\n  \"addressNormalized\": \"123 north main street\",\n  \"countryCode\": \"US\",\n  \"registrationDate\": \"1985-01-15\"\n}\n</code></pre> <p>International example (French):</p> <pre><code>{\n  \"legalName\": \"Soci\u00e9t\u00e9 G\u00e9n\u00e9rale S.A.\",\n  \"countryCode\": \"FR\"\n}\n</code></pre> <p>to:</p> <pre><code>{\n  \"legalNameNormalized\": \"societe generale societe anonyme\",\n  \"addressNormalized\": null,\n  \"countryCode\": \"FR\",\n  \"registrationDate\": null\n}\n</code></pre> <p>International example (Greek):</p> <pre><code>{\n  \"legalName\": \"\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae \u0395\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b1 \u0394\u03b5\u03b4\u03bf\u03bc\u03ad\u03bd\u03c9\u03bd\",\n  \"countryCode\": \"GR\"\n}\n</code></pre> <p>to: a lowercased Greek string with punctuation removed and whitespace collapsed; the script remains Greek, not transliterated or dropped.</p>"},{"location":"en/concepts/normalization/#5-normalization-vs-canonicalization","title":"5. Normalization vs Canonicalization","text":"Stage Purpose Uses Adapter Normalization Clean and map raw records into CEP-friendly fields Adapters / ETL code Core Normalization Unicode-safe, script-preserving string cleanup CEP Rust core Canonicalization Assemble final hash string and compute SNFEI CEP Rust core (SNFEI) <p>Notes: - Adapter normalization may be jurisdiction-specific and can evolve quickly. - Core normalization is global and stable; all implementations must match it. - Canonicalization is purely structural: build the hash pre-image in the agreed order, then hash.</p>"},{"location":"en/concepts/normalization/#6-international-design","title":"6. International Design","text":"<p>This design ensures that:</p> <ul> <li>The same entity produces the same SNFEI across jurisdictions and implementations.</li> <li>Latin-based names behave as expected (diacritics folded, legal suffixes expanded).</li> <li>Non-Latin scripts (Greek, Cyrillic, Han, Arabic, etc.) are first-class citizens, not collateral damage of ASCII-only assumptions.</li> <li>Future language- or country-specific tweaks (e.g. new legal forms) can be layered on via vocabularies and localization files, without rewriting the core.</li> </ul> <p>Normalization is designed to be transparent, domain-aware, and non-destructive, serving as the reliable entrance to the CEP identity pipeline.</p>"},{"location":"en/concepts/related-domains/","title":"Related Research Domains","text":"<p>This standard operates at the intersection of three major, yet often separate, academic research domains:  - Formal Entity Resolution (CS),  - Campaign Finance/Policy Analysis (Political Science), and - Global Data Standards (Information Systems).</p>"},{"location":"en/concepts/related-domains/#prior-work-entity-resolution-data-standards-and-civic-transparency","title":"Prior Work: Entity Resolution, Data Standards, and Civic Transparency","text":"<p>This standard advances the state-of-the-art by bridging the gap between three distinct bodies of work: high-fidelity entity resolution, policy-driven data harmonization, and the development of open standards for public accountability.</p>"},{"location":"en/concepts/related-domains/#1-entity-resolution-and-data-quality-methodology","title":"1. Entity Resolution and Data Quality Methodology","text":"<p>Research in Entity Resolution (ER), also known as record linkage or deduplication, has been a cornerstone of computer science and database theory.</p> <p>Carnegie Mellon University (CMU) has contributed foundational work in formalizing the ER problem, such as the ENRES framework, which provides a semantic model to represent and relate various ER research models. This work highlights the crucial need for formal reasoning and explicit assumptions regarding entities and their references, which directly informs our Category Theory approach. Other CMU-related research has addressed Generic Entity Resolution with Data Confidences, underscoring the necessity of associating numerical confidence with merged records, a feature we implement via the Splink-generated confidence_score.</p> <p>The computational methodology behind our implementation relies heavily on advancements in probabilistic record linkage, particularly the Fellegi-Sunter model, which allows for high-accuracy linking of data without labeled training sets, critical for messy public data. The use of the open-source Splink library (pioneered outside academia and rigorously validated) represents a pragmatic, scalable implementation of these probabilistic principles.</p>"},{"location":"en/concepts/related-domains/#2-campaign-finance-and-policy-data-standardization","title":"2. Campaign Finance and Policy Data Standardization","text":"<p>A parallel track of research has focused on the application of computational methods to clean and analyze fragmented political data.</p> <p>Stanford University's DIME (Database on Ideology, Money in Politics, and Elections) Project exemplifies the effort to centralize and standardize complex political contributions data. DIME has assigned unique identifiers for millions of individual and organizational donors, candidates, and political committees across federal and state elections. This established the value proposition for a persistent, standardized identifier in the campaign finance domain.</p> <p>The University of Chicago MS in Computational Analysis and Public Policy (MSCAPP) and Stanford's Computational Public Policy programs have emphasized the necessary skills, including machine learning, big data, and computational analysis required to address policy issues like public procurement and campaign finance. These programs underscore the academic recognition that robust data infrastructure is the prerequisite for rigorous policy analysis.</p> <p>While these efforts successfully resolve entities within their domain (e.g., within campaign finance), they often use internal, proprietary identifiers that do not readily link to entities in the public procurement or grant domains, creating siloed transparency.</p>"},{"location":"en/concepts/related-domains/#3-open-data-interoperability-and-global-standards","title":"3. Open Data, Interoperability, and Global Standards","text":"<p>The third body of work defines the principles of modern data governance and standardization.</p> <p>Massachusetts Institute of Technology (MIT), through its Research Data Principles, champions the need for researchers to manage data actively and avoid acquiring or generating data that restricts future use and sharing. This principle of \"open by default\" and \"designed for reuse\" informs the design of the our open-source standard and its reliance on the non-proprietary SNFEI.</p> <p>Organizations supporting the Open Data Charter emphasize that data must be comparable and interoperable to enhance governance and accountability. This reflects the global demand for cross-sectoral standards. The existing Legal Entity Identifier (LEI) standard provides the template for a globally harmonized system in the financial sector.</p>"},{"location":"en/concepts/related-domains/#novelty-and-contribution-of-this-standard","title":"Novelty and Contribution of this Standard","text":"<p>This project is novel in three key ways:</p> <ul> <li> <p>Compositional Rigor: We model the civic exchange system as a Category, using Category Theory to formally prove that the SNFEI acts as the Universal Property (Limit) that unifies all messy civic records, helping to guarantee the standard's structural integrity and extensibility.</p> </li> <li> <p>Tiered, Extensible Identity: We address sub-federal identities by explicitly creating the SNFEI (Tier 3) as an open-source bridge to the global LEI (Tier 1) and federal UEI (Tier 2).</p> </li> <li> <p>The Provenance Tag: We enforce a Compositional Provenance Tag that structurally records the Morphism Type (GRANT, CONTRACT_FEE) and the entity hierarchy, enabling automated tracing of the entire funding chain, which goes beyond simple entity deduplication.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/","title":"Research Adoption Landscape","text":"<p>This document outlines how major research communities are likely to view Civic Interconnect (CI) and the Civic Exchange Protocol (CEP). It summarizes why each community might engage, where skepticism might arise, and how CI positions itself for constructive collaboration.</p>"},{"location":"en/concepts/research-adoption/#1-entity-resolution-computer-science-database-theory","title":"1. Entity Resolution (Computer Science / Database Theory)","text":""},{"location":"en/concepts/research-adoption/#why-they-might-engage","title":"Why They Might Engage","text":"<ul> <li> <p>Formal Foundations (Category Theory)   CI/CEP models a civic identity system using categorical constructs, where SNFEI behaves like a universal property (a limit over normalized attributes).   This directly addresses a core CS challenge: entity resolution without ad-hoc heuristics.</p> </li> <li> <p>Tiered Identity Architecture   SNFEI (Tier 3) provides a scalable open identity layer that links up to LEI (Tier 1) and SAM UEI (Tier 2).   This multi-tier architecture matches the complexity seen in large, real-world ER problems.</p> </li> <li> <p>Confidence Scoring Integration   The explicit <code>confidenceScore</code> parallels CMU work on data confidence, uncertainty propagation, and probabilistic entity matching.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#why-they-might-be-skeptical","title":"Why They Might Be Skeptical","text":"<ul> <li> <p>Application Rather Than Breakthrough   ER researchers may consider CI's methods to be an application of known techniques (e.g., Splink-style blocking, Fellegi\u2013Sunter logic) rather than a novel algorithm.</p> </li> <li> <p>Governance and Longevity Concerns   They may worry whether CI/CEP will be maintained long-term or become another abandoned identity standard.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#engagement","title":"Engagement","text":"<ul> <li>CI will publish a formal specification of the SNFEI functor, universal property, and resolution logic.  </li> <li>CI will provide benchmark datasets comparing SNFEI performance to LEI/UEI-style inference.  </li> <li>CI is open to collaborating on probabilistic confidence scoring research and error propagation.</li> </ul>"},{"location":"en/concepts/research-adoption/#2-campaign-finance-policy-analysis-political-science","title":"2. Campaign Finance &amp; Policy Analysis (Political Science)","text":""},{"location":"en/concepts/research-adoption/#why-they-might-engage_1","title":"Why They Might Engage","text":"<ul> <li>Cross-Domain Linking   Policy researchers excel at analyzing campaign finance data within their silo, but may lack cross-silo tools to connect it to:  </li> <li>procurement  </li> <li>lobbying  </li> <li>nonprofit contributions  </li> <li>grants and contracts  </li> </ul> <p>CEP's <code>EntityRecord</code>, <code>RelationshipRecord</code>, and <code>ExchangeRecord</code> directly enable funding-chain analysis across sectors.</p> <ul> <li>Automated Funding Path Tracing   CTags describing morphism types (GRANT, CONTRACT_FEE, DONATION, PASS-THROUGH, etc.) make automated tracing auditable and reproducible.</li> </ul>"},{"location":"en/concepts/research-adoption/#why-they-might-be-skeptical_1","title":"Why They Might Be Skeptical","text":"<ul> <li> <p>Loss of Domain-Specific Detail   CEP acts as a structural transport layer. Policy analysts often need extremely granular attributes (committee type, election cycle).   They may worry CI \"abstracts away\" detail.</p> </li> <li> <p>Existing Internal ID Systems   Groups like DIME already maintain elaborate proprietary IDs.   They may ask: Why adopt another ID system until everyone else does?</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#engagement_1","title":"Engagement","text":"<ul> <li>CI provides CEP's interconnect strategy - it does not replace domain standards, it links them.  </li> <li>CI provides worked examples showing how a campaign finance ID maps to SNFEI and survives joining across datasets.  </li> <li>CI develops a Funding Flow Linkage Script demo using Relationships, Exchanges, and CTags.</li> </ul>"},{"location":"en/concepts/research-adoption/#3-open-data-interoperability-global-standards","title":"3. Open Data / Interoperability / Global Standards","text":""},{"location":"en/concepts/research-adoption/#why-they-might-engage_2","title":"Why They Might Engage","text":"<ul> <li> <p>Strong Alignment with Open Data Principles   CEP is vendor-neutral, open-source, and schema-driven.   It aligns with the Open Data Charter, W3C PROV, and MIT's research data interoperability frameworks.</p> </li> <li> <p>Explicit Provenance &amp; Trust Layer   The envelope's attestations, timestamps, and CTags are directly relevant to modern data governance, AI transparency, and auditability.</p> </li> <li> <p>Extensible Schema Architecture   CEP's use of <code>$ref</code>, <code>allOf</code>, controlled vocabularies, and stable URIs matches best practices in international standards efforts.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#why-they-might-be-skeptical_2","title":"Why They Might Be Skeptical","text":"<ul> <li> <p>No Global Mandate (Yet)   LEI succeeded because the G20 mandated it.   CEP does not have a regulatory or institutional mandate, making adoption voluntary.</p> </li> <li> <p>Complexity Cost   The envelope structure is comprehensive.   Standards bodies may ask whether the complexity is appropriate for small jurisdictions or lightweight open-data platforms.</p> </li> </ul>"},{"location":"en/concepts/research-adoption/#engagement_2","title":"Engagement","text":"<ul> <li>CI provides profiles (minimal subsets) of CEP for lightweight use cases.  </li> <li>CI publishes machine-readable vocabularies following W3C best practices.  </li> <li>CI will define and publish a CEP Lite profile schema (e.g., cep.lite.entity.schema.json) that limits required fields to the absolute minimum (e.g., only verifiableId, recordKind, legalName, jurisdictionIso). This directly addresses the Complexity Cost concern for lightweight platforms.</li> <li>CI will ensure all vocabularies and schemas adhere to W3C best practices (stable URIs, versioning) and that the Attestation model provides a direct path to W3C PROV and Verifiable Credentials compliance.</li> </ul>"},{"location":"en/concepts/research-adoption/#summary-table","title":"Summary Table","text":"Research Community Possible Incentives Possible Concerns CI Contributions Entity Resolution Formal categorical model, canonical identity layer Not a novel algorithm, governance concerns Publish formal proof, provide benchmarks Policy / Campaign Finance Cross-silo linking, automated flow tracing Loss of granularity, existing IDs Show mappings, demos, wrappers Open Data Standards Interoperability, provenance, extensibility No mandate, perceived complexity Provide profiles, pilots, vocabularies"},{"location":"en/examples/","title":"CEP Examples: How to Read and Reproduce Them","text":"<p>The CEP repository includes many example records demonstrating the complete entity and relationship pipeline. This page describes how all examples are structured, what each file represents, and how the Rust + Python toolchain produces the final attested CEP record.</p> <p>Each specific example page (e.g., a municipality, nonprofit, PAC, or contractor) includes only the details unique to that case. This file is the canonical reference for the example pipeline.</p>"},{"location":"en/examples/#directory-structure-of-an-example","title":"Directory Structure of an Example","text":"<p>Every example follows the same four-stage layout:</p> <pre><code>01_raw_source.json    = raw input from an upstream system\n02_normalized.json    = adapter-normalized form (NormalizedEntityInput)\n03_canonical.json     = canonicalized form (Normalizing Functor)\n04_entity_record.json = final EntityRecord from the Rust builder\n</code></pre> <p>For relationship or exchange examples, the fourth file will be a <code>RelationshipRecord</code> or <code>ExchangeRecord</code>, but the pipeline stages remain the same.</p>"},{"location":"en/examples/#stage-1-raw-source-normalized-input","title":"Stage 1 \u2014 Raw Source \u2192 Normalized Input","text":"<p>The adapter reads <code>01_raw_source.json</code> and produces <code>02_normalized.json</code>.</p> <p>Normalization ensures:</p> <ul> <li>consistent Unicode handling  </li> <li>consistent whitespace and punctuation cleanup  </li> <li>deterministic field names  </li> <li>structured jurisdiction and entity-type fields  </li> <li>extraction of identifier inputs (e.g., SNFEI, SAM.gov, state vendor IDs)</li> </ul> <p>Normalization is implemented in Python using shared utilities from <code>cep_py</code>.</p>"},{"location":"en/examples/#stage-2-normalized-input-canonical-input","title":"Stage 2 \u2014 Normalized Input \u2192 Canonical Input","text":"<p>The canonicalization stage applies the normalizing functor implemented in Rust (<code>cep_core</code>) and exposed through Python.</p> <p>Canonicalization:</p> <ul> <li>orders fields deterministically  </li> <li>converts complex structures into canonical hash-preimage form  </li> <li>produces a stable <code>to_hash_string()</code> representation</li> </ul> <p>Any two semantically identical civic records must canonicalize to the same string.</p>"},{"location":"en/examples/#stage-3-canonical-input-verifiable-id","title":"Stage 3 \u2014 Canonical Input \u2192 Verifiable ID","text":"<p>From the canonical string, the Rust core computes the Verifiable ID.</p> <p>For entities, this may use:</p> <ul> <li>SNFEI (SHA-256 based)  </li> <li>OR a multi-identifier universal construction  </li> <li>OR a future identifier system  </li> </ul> <p>The Verifiable ID serves as the stable identity of the entity across all revisions.</p> <p>If the example includes additional identifiers, they are incorporated into the <code>identifiers[]</code> block.</p>"},{"location":"en/examples/#stage-4-build-the-final-record-rust-builder","title":"Stage 4 \u2014 Build the Final Record (Rust Builder)","text":"<p>In the final stage, Python calls into the Rust <code>cep_core</code> builder:</p> <pre><code>from cep_py import build_entity_json\nrecord = build_entity_json(normalized_input)\n</code></pre> <p>The builder:</p> <ol> <li>Confirms or computes the Verifiable ID  </li> <li>Creates or extends the non-destructive revision chain </li> <li>Computes <code>recordHash</code> and <code>previousRecordHash</code> </li> <li>Fills required envelope fields (status, timestamps, jurisdiction, type)  </li> <li>Generates a cryptographic attestation using the configured keys</li> </ol> <p>This produces <code>04_entity_record.json</code>.</p> <p>If a prior revision exists, a new one is added without overwriting history.</p>"},{"location":"en/examples/#how-cep-invariants-appear-in-examples","title":"How CEP Invariants Appear in Examples","text":"<p>All examples share these foundational guarantees:</p>"},{"location":"en/examples/#verifiable-id-as-a-universal-construction","title":"Verifiable ID as a Universal Construction","text":"<p>Identity is derived canonically and remains stable across revisions.</p>"},{"location":"en/examples/#non-destructive-revision-chain","title":"Non-Destructive Revision Chain","text":"<p>Every new build creates a new revision linked by <code>previousRecordHash</code>.</p>"},{"location":"en/examples/#immutable-provenance","title":"Immutable Provenance","text":"<p>Hashes guarantee that revision history cannot be altered without detection.</p>"},{"location":"en/examples/#cryptographic-attestation","title":"Cryptographic Attestation","text":"<p>Records are attested using independent keys; verification does not depend on trusting any hosting service.</p>"},{"location":"en/examples/#distributed-verification-implicit","title":"Distributed Verification (implicit)","text":"<p>Examples can be validated locally, offline, or in distributed environments.</p>"},{"location":"en/examples/#regenerating-any-example","title":"Regenerating Any Example","text":"<p>From the repository root:</p> <pre><code>uv run cx generate-example --path examples/.../&lt;example-folder&gt;/\n</code></pre> <p>Or run manually:</p> <pre><code>from cep_py import (\n    normalize_entity_input,\n    canonicalize_entity_input,\n    compute_verifiable_id,\n    build_entity_json,\n)\n</code></pre> <p>(Examples may use <code>compute_snfei</code> or other identifier constructors depending on the schema version.)</p>"},{"location":"en/examples/#template-for-example-specific-pages","title":"Template for Example-Specific Pages","text":"<p>Each example page should include:</p> <pre><code># Example: &lt;Name&gt;\n\n**Purpose:** (What this example highlights \u2014 unique bits only)\n\n**Files:**\n- 01_raw_source.json\n- 02_normalized.json\n- 03_canonical.json\n- 04_entity_record.json\n\n**Highlights:**\n- Unique identifiers\n- Special normalization rules\n- Unusual entityType or jurisdiction\n- Notes on revision history (if multiple revisions)\n\n**Link back to this page:**\nSee [How CEP Examples Work](../README.md) for the full pipeline description.\n</code></pre> <p>This keeps example pages small and consistent.</p>"},{"location":"en/examples/#where-to-find-example-definitions","title":"Where to Find Example Definitions","text":"<p>Examples live under:</p> <pre><code>examples/\n    entity/\n    relationship/\n    exchange/\n</code></pre> <p>Each example folder includes its own markdown page and the four pipeline files.</p> <p>This page is the authoritative description of how CEP examples work. All example pages link back here for more complete information.</p>"},{"location":"en/examples/entity-with-snfei/","title":"Example: CEP EntityRecord with SNFEI","text":"<p>This example demonstrates how a CEP <code>EntityRecord</code> includes a Structured Non-Fungible Entity Identifier (SNFEI) when an entity does not have a national or global registry ID (such as LEI or SAM-UEI). SNFEI provides a deterministic, recomputable identifier for joining datasets across civic, nonprofit, educational, and local-government domains.</p>"},{"location":"en/examples/entity-with-snfei/#input-normalized-entity-payload","title":"Input (Normalized Entity Payload)","text":"<p>This is the minimal normalized payload an adapter or ETL process would emit:</p> <pre><code>{\n    \"jurisdictionIso\": \"US-MN\",\n    \"legalName\": \"Example School District 123\",\n    \"legalNameNormalized\": \"example school district 123\",\n    \"snfei\": \"34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\",\n    \"entityType\": \"educational-institution\"\n}\n</code></pre> <p>The SNFEI here is the SHA-256 hash of the canonical input string:</p> <p><code>legalNameNormalized|addressNormalized|countryCode|registrationDate</code></p> <p>Empty/None fields are included as empty strings to keep positions stable.</p> <p>Example (no address, no registration date):</p> <p><code>example school district 123||US|</code></p> <p>Example (with address, no registration date):</p> <p><code>new york school district 01|200 learning street|US|</code></p>"},{"location":"en/examples/entity-with-snfei/#output-cep-entityrecord","title":"Output (CEP EntityRecord)","text":"<p>After running this normalized input through the CEP builder, the resulting <code>EntityRecord</code> looks like this:</p> <pre><code>{\n    \"recordKind\": \"entity\",\n    \"recordSchemaUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/schemas/core/cep.entity.schema.json\",\n    \"schemaVersion\": \"1.0.0\",\n    \"revisionNumber\": 1,\n\n    \"verifiableId\": \"cep-entity:snfei:34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\",\n    \"recordTypeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/core/entity-type.json#educational-institution\",\n\n    \"status\": {\n        \"statusCode\": \"ACTIVE\",\n        \"statusEffectiveDate\": \"1900-01-01\"\n    },\n\n    \"timestamps\": {\n        \"firstSeenAt\": \"1900-01-01T00:00:00.000000Z\",\n        \"lastUpdatedAt\": \"1900-01-01T00:00:00.000000Z\",\n        \"validFrom\": \"1900-01-01T00:00:00.000000Z\"\n    },\n\n    \"attestations\": [\n        {\n            \"attestationTimestamp\": \"1900-01-01T00:00:00.000000Z\",\n            \"attestorId\": \"cep-entity:example:ingest\",\n            \"verificationMethodUri\": \"urn:cep:attestor:cep-entity:example:ingest\",\n            \"proofType\": \"ManualAttestation\",\n            \"proofPurpose\": \"assertionMethod\"\n        }\n    ],\n\n    \"jurisdictionIso\": \"US-MN\",\n    \"legalName\": \"Example School District 123\",\n    \"legalNameNormalized\": \"example school district 123\",\n\n    \"identifiers\": [\n        {\n            \"schemeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-identifier-scheme.v1.0.0.json#snfei\",\n            \"identifier\": \"34486b382c620747883952d6fb4c0ccdbf25388dfb0bb99231f33a93ad5ca5b3\"\n        }\n    ]\n}\n</code></pre>"},{"location":"en/examples/entity-with-snfei/#key-points","title":"Key Points","text":""},{"location":"en/examples/entity-with-snfei/#deterministic-id","title":"Deterministic ID","text":"<p>The <code>verifiableId</code> incorporates the SNFEI value to create a stable, recomputable entity identifier:</p> <pre><code>cep-entity:snfei:&lt;hash&gt;\n</code></pre>"},{"location":"en/examples/entity-with-snfei/#vocabulary-backed-identifier-scheme","title":"Vocabulary-backed Identifier Scheme","text":"<p>The SNFEI entry references the official vocabulary term:</p> <pre><code>https://raw.githubusercontent.com/civic-interconnect/civic-interconnect/main/vocabulary/entity-identifier-scheme.v1.0.0.json#snfei\n</code></pre> <p>This ensures consistent identifier semantics across systems.</p>"},{"location":"en/examples/entity-with-snfei/#minimal-but-complete-envelope","title":"Minimal but Complete Envelope","text":"<p>Even in a minimal example, CEP includes:</p> <ul> <li>envelope metadata (<code>recordKind</code>, <code>schemaVersion</code>)</li> <li>timestamps</li> <li>an attestation block</li> <li>status envelope</li> </ul>"},{"location":"en/examples/entity-with-snfei/#when-to-use-snfei","title":"When to Use SNFEI","text":"<p>Use SNFEI when:</p> <ul> <li>an entity lacks LEI, SAM-UEI, or other authoritative identifiers,</li> <li>datasets need a stable join key,</li> <li>building civic registries,</li> <li>integrating multiple heterogeneous data sources.</li> </ul> <p>SNFEI is a deterministic, transparent identifier that enables cross-dataset linkage without a central registry.</p>"},{"location":"en/governance/cep-foundational-principles/","title":"CEP Foundational Principles","text":"<p>This document identifies the foundational architectural invariants required for the Civic Exchange Protocol (CEP) to function as a deterministic, compositional, and verifiable system across diverse civic domains.</p>"},{"location":"en/governance/cep-foundational-principles/#1-canonical-serialization-cec","title":"1. Canonical Serialization (CEC)","text":"<p>CEP requires a stable, deterministic canonical encoding for all entities, relationships, and exchanges. This includes:</p> <ul> <li>key ordering</li> <li>omission rules for null/empty fields</li> <li>Unicode normalization</li> <li>numeric normalization</li> <li>canonical list ordering</li> <li>no ambiguity in datatype representation</li> </ul> <p>CEC is mandatory for hashing, deduplication, and cross-system verification.</p>"},{"location":"en/governance/cep-foundational-principles/#2-cross-domain-entity-identity","title":"2. Cross-Domain Entity Identity","text":"<p>All domains must support a common identity model grounded in:</p> <ul> <li>minimal identity-defining attributes</li> <li>domain-agnostic fingerprint rules</li> <li>deterministic merge semantics</li> <li>stable identifier construction</li> </ul> <p>Identity must be consistent across campaigns, environment, education, municipalities, nonprofits, etc.</p>"},{"location":"en/governance/cep-foundational-principles/#3-graph-level-normalization","title":"3. Graph-Level Normalization","text":"<p>Provenance, merges, and entity graphs must have:</p> <ul> <li>canonical ordering of edges</li> <li>deterministic blank-node labeling</li> <li>merge strategy determinism</li> <li>recursion guards during rewriting</li> </ul> <p>This ensures stable cross-domain provenance and reproducible entity histories.</p>"},{"location":"en/governance/cep-foundational-principles/#4-vocabulary-and-schema-versioning","title":"4. Vocabulary and Schema Versioning","text":"<p>CEP vocabularies evolve. Therefore:</p> <ul> <li>each vocabulary entry MUST define a stable URI</li> <li>deprecated terms are never reused</li> <li>canonicalization must state vocabulary version</li> <li>adapters must declare the vocab version they target</li> </ul> <p>Versioning is part of the trust model.</p>"},{"location":"en/governance/cep-foundational-principles/#5-adapter-algebra","title":"5. Adapter Algebra","text":"<p>Adapters form a category of typed rewriting morphisms:</p> <ul> <li>each adapter has a domain and codomain schema</li> <li>composition must be well-defined and deterministic</li> <li>identity adapters must exist for each schema version</li> <li>adapters MUST document partiality (when they can fail)</li> </ul> <p>CEP interoperability relies on predictable adapter composition.</p>"},{"location":"en/governance/cep-foundational-principles/#6-global-integrity-constraints","title":"6. Global Integrity Constraints","text":"<p>All domains must adhere to:</p> <ul> <li>unique verifiable IDs</li> <li>referential integrity for entity relationships</li> <li>attestation timestamps \u2265 dependency timestamps</li> <li>symmetry/antisymmetry rules for relationships as needed</li> </ul> <p>These constraints prevent inconsistent or unverifiable data.</p>"},{"location":"en/governance/cep-foundational-principles/#7-security-and-attestation","title":"7. Security and Attestation","text":"<p>Every CTag (cryptographic tag) must:</p> <ul> <li>commit to a canonical serialization (CEC)</li> <li>state the vocabulary version</li> <li>state the adapter version</li> <li>include attestation metadata</li> <li>guard against canonicalization confusion</li> </ul> <p>Security is inseparable from canonicalization.</p>"},{"location":"en/governance/cep-foundational-principles/#8-minimal-feature-set-for-unique-identification","title":"8. Minimal Feature Set for Unique Identification","text":"<p>Across all domains CEP defines:</p> <ul> <li>minimal identity-defining attributes</li> <li>additional non-identity metadata</li> <li>optional descriptive context</li> </ul> <p>Identity must be explicit and separable from metadata.</p>"},{"location":"en/governance/cep-foundational-principles/#summary","title":"Summary","text":"<p>These eight principles are the architectural backbone of CEP. They define the minimal mathematical and engineering structure necessary for CEP to function as a unified, multi-domain rewriting system supporting canonicalization, hashing, provenance, and exchange.</p>"},{"location":"en/governance/evolution-policy-and-versioning/","title":"Standard Evolution Policy and Versioning","text":"<p>This policy defines the process, requirements, and responsibilities for introducing changes to the Protocol.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#1-versioning-system","title":"1. Versioning System","text":"<p>The standard utilizes Semantic Versioning (MAJOR.MINOR.PATCH). The version number applies to the entire monorepo and its core protocol requirements.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#11-major-version-change-x00","title":"1.1 MAJOR Version Change (X.0.0)","text":"<p>A MAJOR change is reserved for non-backwards-compatible modifications that require all certified nodes to update their serialization logic, otherwise, they will lose hash parity.</p> Change Type Impact Example Data Type Change Changing a field type (e.g., transactionAmount from number to string). Field Order Change Modifying the CANONICAL_FIELD_ORDER. Cryptographic Change Switching from SHA-256 to a new algorithm (e.g., SHA-384). Mandatory Field Addition Adding a new field to the required list in the JSON Schema. <p>Requirement: Requires unanimous approval from the Interconnect Standards Board (ISB) and a mandatory 6-month deprecation period.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#12-minor-version-change-0x0","title":"1.2 MINOR Version Change (0.X.0)","text":"<p>A MINOR change is a backwards-compatible modification that adds new functionality or optional fields. Existing certified nodes maintain hash parity, but new nodes may need to account for new optional data.</p> Change Type Impact Example Optional Field Addition Adding a new field to the end of the CANONICAL_FIELD_ORDER (which is omitted if null). Adding funding_source_project_id (optional). Enum Value Addition Adding a new value to an existing enum (e.g., adding TEMPORARILY_SUSPENDED to transactionStatus). Tooling Upgrade Significant upgrade to the build system (build.sh or testing dependencies). <p>Requirement: Requires simple majority approval from the ISB (2 out of 3 votes).</p>"},{"location":"en/governance/evolution-policy-and-versioning/#13-patch-version-change-00x","title":"1.3 PATCH Version Change (0.0.X)","text":"<p>A PATCH change is a small, fully backwards-compatible correction to documentation, tooling, or non-protocol code.</p> Change Type Impact Example Documentation Fix Correcting a typo in the Governance Charter. Test Data Update Adding a new test vector to /test_data that uses only existing fields. Non-Core Bug Fix Fixing a non-critical bug in a reference implementation's example code. <p>Requirement: Can be approved by the ISB Chair alone.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#2-change-submission-and-review-cycle","title":"2. Change Submission and Review Cycle","text":"<ol> <li> <p>Proposal Submission: The contributor submits a Pull Request (PR) against the main branch.</p> </li> <li> <p>Versioning Assignment: The ISB Chair assigns the PR a tentative version bump (MAJOR, MINOR, or PATCH) based on Section 1.</p> </li> <li> <p>ISB Review and Vote: The ISB reviews the proposal (focusing on need and impact) and votes according to the requirement for the assigned version type.</p> </li> <li> <p>Hash Parity Enforcement: Once the vote passes, the PR is merged, and the automated CI system executes the build.sh script to confirm 100% hash parity across all five certified languages (Python, Rust, Java, C#, TypeScript). No release can occur until 100% parity is confirmed.</p> </li> <li> <p>Release: The new version is tagged, and all certified node operators are notified.</p> </li> </ol>"},{"location":"en/governance/objectives-and-vision/","title":"Objectives and Vision","text":"<p>The Civic Exchange Protocol (CEP) is designed to support incremental integration today and strategic planning without requiring architectural changes. The core philosophy is simple:</p> <ul> <li>Optimize for low-cost, low-friction adoption.</li> <li>Provide cryptographic integrity without requiring blockchain.</li> <li>Support regulatory harmonization across jurisdictions.</li> <li>Preserve openness, interoperability, and vendor neutrality.</li> </ul> <p>At its core, CEP ensures that the same payload always yields the same canonical hash, providing a universal identity and attestation mechanism that can span civic, financial, and administrative systems.</p>"},{"location":"en/governance/objectives-and-vision/#1-objectives","title":"1. Objectives","text":""},{"location":"en/governance/objectives-and-vision/#11-lower-the-cost-of-adoption","title":"1.1 Lower the Cost of Adoption","text":"<p>Most public-sector technology initiatives fail due to the cost and complexity of onboarding. CEP minimizes this by:</p> <ul> <li>Requiring only JSON + SHA-256 + a canonical string rule.</li> <li>Avoiding specialized infrastructure (no distributed ledger, no proprietary middleware).</li> <li>Allowing any language, platform, or agency to participate.</li> <li>Transparency by default: schemas and vocabularies are openly published.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#12-decentralized-provenance-without-blockchain","title":"1.2 Decentralized Provenance Without Blockchain","text":"<p>Unlike blockchain-based solutions, CEP:</p> <ul> <li>Requires no consensus algorithm.</li> <li>Does not impose token economics or distributed nodes.</li> <li>Uses a cryptographically linked attestation chain (previousRecordHash), providing tamper evidence at a fraction of the cost.</li> </ul> <p>This provides a cryptographic audit trail suitable for public-sector systems where full decentralization is either unnecessary or impractical.</p>"},{"location":"en/governance/objectives-and-vision/#13-cost-effective-regulatory-compliance","title":"1.3 Cost-Effective Regulatory Compliance","text":"<p>CEP is designed to satisfy emerging demands in:</p> <ul> <li>Transparency and anti-corruption policy  </li> <li>Cross-jurisdiction financial tracking  </li> <li>Federal reporting (XBRL, GTAS)  </li> <li>Global financial identity standards (UEI, LEI)</li> </ul> <p>By structuring the data model around canonical identifiers, provenance, and hash-bound attestations, CEP can adapt naturally to future regulatory frameworks and programmatic audit requirements.</p>"},{"location":"en/governance/objectives-and-vision/#2-vision","title":"2. Vision","text":"<p>The Civic Exchange Protocol is deliberately designed so that incremental adoption today will not conflict with expected future requirements.</p> <p>Possible evolution includes:</p> <ul> <li>National or state-level directives requiring provenance tagging for grant, contract, or procurement systems.</li> <li>Standardization bodies adopting CEP as a formal schema for intergovernmental reporting.</li> <li>Regulatory requirements for immutable audit trails for public money flows.</li> <li>International harmonization with LEI, XBRL, HSDS, PROV, Popolo, or other standards.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#3-voluntary-integration-vs-possible-future-requirements-matrix","title":"3. Voluntary Integration vs. Possible Future Requirements Matrix","text":"<p>This matrix outlines the anticipated pathway from voluntary use to potential regulatory mandate. The protocol is built to operate seamlessly in both contexts.</p> Aspect Current Voluntary Integration Possible Future Requirements Authority Interconnect Standards Board (ISB) governs versions, vocabularies, and hash rules. Department of Governance and Exchange (DOGE) as regulatory authority for compliance and enforcement. Access Policy Peer-to-peer agreements between participating entities. Standardized Digital Roles and Permissions (SDRP), federally or globally recognized. Public Data Best practice for transparency. Agencies may decide which data to publish. Mandatory global disclosures for specific categories (e.g., grants, contracts, campaign finance). Integrity Proof Entity Hash and canonical string provide voluntary integrity guarantee. Same Entity Hash meets any required SSOT-proof for compliance and audits. <p>CEP ensures that the same proof mechanism works in both cases, with no need for new cryptographic infrastructure should mandated requirements arrive.</p>"},{"location":"en/governance/objectives-and-vision/#4-future-proof-architecture","title":"4. Future-Proof Architecture","text":"<p>CEP is explicitly designed to:</p> <ul> <li>Scale from a few adopters to wider integration.</li> <li>Allow community-driven vocabulary evolution.</li> <li>Support new jurisdictions, formats, and regulatory requirements without schema breakage.</li> <li>Provide a secure, verifiable, and interoperable foundation for multi-sector data exchange.</li> </ul> <p>The vision is an interoperable civic identity and provenance network, offering incremental integration and compatibility with existing systems.</p>"},{"location":"en/governance/objectives-and-vision/#5-stewardship-and-sustainability","title":"5. Stewardship and Sustainability","text":"<p>Sustainability of the ecosystem emphasizes:</p> <ul> <li>Open governance via the Interconnect Standards Board  </li> <li>Versioning discipline to protect downstream adopters  </li> <li>Long-term archival guarantees through schema versioning and stable URIs  </li> <li>Transparency and accountability in vocabulary evolution, attestation practices, and protocol changes  </li> </ul> <p>CEP is designed to be maintainable, publicly governed, and aligned with global interoperability principles.</p>"},{"location":"en/governance/vocabulary-process/","title":"Vocabulary Governance Process","text":"<p>This document defines how controlled vocabularies in the Civic Exchange Protocol (CEP) are created, reviewed, versioned, and published. CEP vocabularies include:</p> <ul> <li><code>entity-type</code></li> <li><code>relationship-type</code></li> <li><code>exchange-type</code></li> <li><code>exchange-role</code></li> <li><code>party-role</code></li> <li><code>identifier-scheme</code></li> <li><code>source-system</code></li> <li><code>resolution-method</code></li> <li><code>value-type</code></li> </ul> <p>These vocabularies provide the stable semantic backbone for CEP interoperability across government systems, academic research, and third-party implementations.</p>"},{"location":"en/governance/vocabulary-process/#1-purpose-of-vocabularies","title":"1. Purpose of Vocabularies","text":"<p>CEP vocabularies serve three critical functions:</p> <ol> <li> <p>Interoperability:    Terms map to external standards (Popolo, Open Civic Data, OCDS, HSDS, Schema.org, XBRL, W3C PROV).</p> </li> <li> <p>Semantic Stability:    Terms provide canonical meaning for entity types, role types, relationship types, exchange types, etc.</p> </li> <li> <p>Verifiable Behavior:    Terms are referenced in canonical URI form inside attested CEP records, affecting hash parity and revision integrity.</p> </li> </ol>"},{"location":"en/governance/vocabulary-process/#2-versioning","title":"2. Versioning","text":"<p>Vocabulary files follow independent semantic versioning:</p> <p><code>&lt;name&gt;.vMAJOR.MINOR.PATCH.json</code></p> <p>Examples:  </p> <pre><code>entity-type.v1.0.0.json\nidentifier-scheme.v1.0.0.json\n</code></pre>"},{"location":"en/governance/vocabulary-process/#21-major","title":"2.1 MAJOR","text":"<p>Changes that break compatibility or reinterpret existing terms: - renaming or removing terms - redefining meanings - altering term URIs - significant structural changes</p> <p>Requires unanimous ISB approval + 6-month deprecation period.</p>"},{"location":"en/governance/vocabulary-process/#22-minor","title":"2.2 MINOR","text":"<p>Backward-compatible enhancements: - adding new terms - adding new mappings - adding optional properties</p> <p>Requires simple majority vote.</p>"},{"location":"en/governance/vocabulary-process/#23-patch","title":"2.3 PATCH","text":"<p>No semantic change: - fixing typos - adding external references in <code>seeAlso</code> - clarifying descriptions</p> <p>May be approved by ISB Chair alone.</p>"},{"location":"en/governance/vocabulary-process/#3-adding-updating-or-deprecating-terms","title":"3. Adding, Updating, or Deprecating Terms","text":"<p>All vocabulary modifications follow this structured workflow:</p>"},{"location":"en/governance/vocabulary-process/#step-1-proposal-submission","title":"Step 1 \u2014 Proposal Submission","text":"<p>A contributor submits a PR that includes: - updated vocabulary file - accompanying rationale - impact assessment on interoperability - references to external standards (if relevant)</p>"},{"location":"en/governance/vocabulary-process/#step-2-technical-review","title":"Step 2 \u2014 Technical Review","text":"<p>The Interconnect Standards Board (ISB) reviews: - term clarity and definition - hierarchy (<code>parentTermUri</code>) - mappings to external standards (SKOS-style) - URI stability - potential namespace collisions - hash-parity implications</p>"},{"location":"en/governance/vocabulary-process/#step-3-vote","title":"Step 3 \u2014 Vote","text":"<p>Version bump category determines voting requirements (Section 2).</p>"},{"location":"en/governance/vocabulary-process/#step-4-merge-release","title":"Step 4 \u2014 Merge &amp; Release","text":"<p>Upon approval: - CI validates JSON format, unique URIs, and mapping integrity - The vocabulary is merged into <code>main</code> - A new tag is created:</p> <p><code>vocab/&lt;name&gt;/vMAJOR.MINOR.PATCH</code></p>"},{"location":"en/governance/vocabulary-process/#step-5-deprecation-notices","title":"Step 5 \u2014 Deprecation Notices","text":"<p>If a term becomes deprecated: - it is retained with <code>\"status\": \"deprecated\"</code> - <code>\"deprecationNote\"</code> must point to its replacement - canonical JSON schemas continue accepting it unless a MAJOR bump occurs</p>"},{"location":"en/governance/vocabulary-process/#4-design-principles-for-vocabulary-terms","title":"4. Design Principles for Vocabulary Terms","text":""},{"location":"en/governance/vocabulary-process/#41-term-uris-must-be-globally-stable","title":"4.1 Term URIs MUST be globally stable","text":"<p>URIs never change after publication.</p>"},{"location":"en/governance/vocabulary-process/#42-labels-are-human-friendly-codes-are-machine-friendly","title":"4.2 Labels are human-friendly; codes are machine-friendly","text":"<p>Examples: - code: <code>prime-contract</code> - label: <code>Prime Contract</code></p>"},{"location":"en/governance/vocabulary-process/#43-definitions-must-be-unambiguous","title":"4.3 Definitions MUST be unambiguous","text":"<p>Definitions MUST avoid jurisdiction-specific assumptions unless explicitly scoped.</p>"},{"location":"en/governance/vocabulary-process/#44-hierarchies-should-be-used-where-meaningful","title":"4.4 Hierarchies SHOULD be used where meaningful","text":"<p>Example: - <code>subgrant</code> \u2192 parent: <code>grant-award</code> - <code>subcontract</code> \u2192 parent: <code>prime-contract</code></p>"},{"location":"en/governance/vocabulary-process/#45-external-mappings-should-be-included","title":"4.5 External mappings SHOULD be included","text":"<p>Supported mapping types: <code>exactMatch</code>, <code>broadMatch</code>, <code>narrowMatch</code>, <code>relatedMatch</code>.</p>"},{"location":"en/governance/vocabulary-process/#5-file-placement-and-structure","title":"5. File Placement and Structure","text":"<p>All vocabulary files live under <code>vocabulary/</code>.</p> <p>Each file follows the canonical <code>cep.vocabulary.schema.json</code>.</p>"},{"location":"en/governance/vocabulary-process/#6-lifecycle-summary","title":"6. Lifecycle Summary","text":"Stage Description Output Proposal Contributor suggests new/updated term Pull Request Review ISB evaluates definition + mappings Comments Vote Approve/reject based on version category Decision Release Publish new vocabulary version New <code>vX.Y.Z</code> tag Deprecation Old terms marked deprecated Maintained until next MAJOR"},{"location":"en/governance/vocabulary-process/#7-guiding-objective","title":"7. Guiding Objective","text":"<p>The primary objective of CEP vocabulary governance is to stabilize meaning, maximize interoperability, and ensure backward compatibility while allowing the ecosystem to grow with new policy types, relationship structures, data standards, and domain models.</p>"},{"location":"en/reference/compatibility-matrix/","title":"Compatibility Matrix","text":"<p>Alignment of CEP and CTags with Existing Civic Standards and Ecosystems</p> <p>This matrix summarizes how Civic Interconnect integrates with leading civic data standards and common government systems. CEP provides the cross-domain structure; CTags provide the provenance layer.</p>"},{"location":"en/reference/compatibility-matrix/#overview-table","title":"Overview Table","text":"Standard / System What It Covers How CEP Integrates How CTags Integrate Value Added Open Civic Data (OCD) Jurisdictions, political divisions, IDs CEP entities reference OCD division IDs; relationships anchored to geography CTags reference jurisdiction identifiers when provenance is location-based Shared geography layer; consistent identifiers Popolo People, organizations, memberships CEP entities map to Popolo-style person/organization structures CTags reference actors involved in document creation or modification Unified identity layer compatible with many civic tools OCDS (Open Contracting Data Standard) Contracting lifecycle (tender &gt; award &gt; contract &gt; implementation) CEP exchanges wrap OCDS documents or link to specific lifecycle stages CTags attach to RFPs, bids, contracts, amendments End-to-end traceability across procurement W3C PROV General-purpose provenance ontology CEP aligns conceptually via entities/activities CTags act as a lightweight PROV profile Semantic-web compatibility without complexity FOIA / Public Records Vendor Systems Submission, routing, review, redaction, release CEP exchanges represent request/response workflows CTags track document lineage and redactions Zero-friction integration; better audit trails Procurement / ERP Systems Contracts, POs, invoices, amendments CEP structures the entity/relationship context; exchanges represent filings CTags document transformations, OCR, AI assistance Stronger compliance and cross-system linking Grant Reporting Systems Awards, periodic reports, audits CEP models multi-stage reporting as exchanges CTags attach to each submitted artifact Simplified compliance, especially for small jurisdictions AI / LLM Systems Retrieval, summarization, classification, transformation CEP provides structured context and stable IDs CTags record chain-of-transformation for AI outputs Transparent AI workflows; verifiable lineage"},{"location":"en/reference/compatibility-matrix/#notes","title":"Notes","text":"<ul> <li>CEP is intentionally schema-light and integrative, not a replacement for existing domain standards.  </li> <li>CTags remain artifact-level and can be used independently.  </li> <li>Combined, they enable transparent, interoperable, AI-ready civic data pipelines across institutions, vendors, and research ecosystems.</li> </ul>"},{"location":"en/reference/reference-projects/","title":"Reference Projects: GitHub Data Standards","text":"<p>There are categories of open-source projects on GitHub that offer great examples, particularly concerning common data schemas, multi-language support, and provenance tracking.</p>"},{"location":"en/reference/reference-projects/#1-interoperability-event-specifications-cross-platform","title":"1. Interoperability &amp; Event Specifications (Cross-Platform)","text":"<p>These standards focus on defining a common data format to ensure different systems and languages can communicate seamlessly. They typically define schemas and transport rules.</p>"},{"location":"en/reference/reference-projects/#cloudevents-specification","title":"CloudEvents Specification","text":"<p>This specification describes event data in a common way. It is designed to simplify event declaration and delivery across services, platforms, and languages (e.g., Go, Java, Python, C#).</p> <p>It's a good example of a cross-platform specification managed openly on GitHub. It defines a mandatory set of attributes (like a base entity identifier) that must be present in every data payload.</p> <p>Link: https://github.com/cloudevents/spec</p>"},{"location":"en/reference/reference-projects/#cdevents-specification","title":"CDEvents Specification","text":"<p>This is a popular specification for Continuous Delivery events, extending CloudEvents by introducing purpose and semantics to the event data.</p> <p>It shows how a standard is built on top of another standard (CloudEvents), specializing the common metadata for a specific domain (CI/CD provenance and flow).</p> <p>Link: https://github.com/cdevents/spec</p>"},{"location":"en/reference/reference-projects/#2-provenance-and-data-tracking-standards","title":"2. Provenance and Data Tracking Standards","text":"<p>These projects relate to provenance aspects, focusing on tracking the history, inputs, and derivation of data.</p>"},{"location":"en/reference/reference-projects/#prov-cpl-core-provenance-library","title":"PROV-CPL (Core Provenance Library)","text":"<p>This is the Core Provenance Library for collecting data provenance with multiple language bindings (C/C++, Java, Python, R). It uses the W3C PROV standard as its foundation.</p> <p>It demonstrates a multi-language implementation of a provenance standard, providing APIs to record who/what/when/where data was created, which is central to provenance.</p> <p>Link: https://github.com/ProvTools/prov-cpl</p>"},{"location":"en/reference/reference-projects/#3-general-data-schemas-and-monorepo-structure","title":"3. General Data Schemas and Monorepo Structure","text":"<p>These focus on using JSON Schema to define strict data structures and managing them in a versioned repository.</p>"},{"location":"en/reference/reference-projects/#json-schema-specification","title":"JSON Schema Specification","text":"<p>This is the official specification for JSON Schema, a declarative language used to annotate and validate JSON documents.</p> <p>This foundational tool is by many standards (including CloudEvents) to define specific fields and types. This repo illustrates how a core schema standard is defined and versioned.</p> <p>Link: https://github.com/json-schema-org/json-schema-spec</p>"},{"location":"en/reference/reference-projects/#consumer-data-standards-australian-dsb-schemas","title":"Consumer Data Standards (Australian DSB Schemas)","text":"<p>This repository holds a collection of JSON schema files derived from the Australian Consumer Data Standards, used for robust schema validation in banking and energy sectors.</p> <p>This offers a practical example of a large-scale data standard implementation in a monorepo (single repository), organized by release version, providing strict, enforceable JSON schemas for real-world data exchange.</p> <p>Link: https://github.com/ConsumerDataStandardsAustralia/dsb-schema-tools</p>"},{"location":"en/reference/reference-standards/","title":"Reference Standards","text":""},{"location":"en/reference/reference-standards/#associated-standards","title":"Associated Standards","text":"Standard/Acronym Purpose Why We Interface XBRL (eXtensible Business Reporting Language) The international standard for electronic transmission of business and financial data (e.g., SEC and FDIC filings use it). We map its transactional fields directly to the relevant XBRL taxonomy elements for regulatory compliance reporting. LEI (Legal Entity Identifier) Global standard for identifying parties to financial transactions worldwide. While the UEI is authoritative in the U.S. government space, our protocol needs to contain a field for the LEI if the entity is globally registered, ensuring compliance for any international transactions. W3C PROV (Provenance) The World Wide Web Consortium standard for recording the historical lifecycle and data quality of a piece of information. Our core value is Provenance. We adopt the principles of W3C PROV to formally define how data history, revisions, and sources are timestamped and logged. GTAS (Government-wide Treasury Account Symbol) The framework used by the Treasury for standardized federal financial reporting. Transactional data (e.g., amounts, categories) must be translatable into GTAS fields for seamless reporting up to the Treasury level."},{"location":"en/reference/reference-standards/#bridge","title":"Bridge","text":"<ul> <li>Official U.S UEI: The U.S. government already uses a Unique Entity Identifier (UEI), a 12-character alphanumeric ID assigned by SAM.gov, for all entities receiving federal financial assistance or doing business with the federal government (Source 3.1, 3.2). Often does not appear on state/local campaign finance reports or local school district consultant contracts unless federal funds are directly involved.</li> <li>Open-Source Data Cleaning Tools: Tools like Splink, OpenRefine, and Python/Pandas to manually clean and standardize messy names (\"Acme Consulting, LLC\" vs. \"Acme Consulting\") (Source 2.1, 2.3).</li> </ul>"},{"location":"en/reference/w3c-prov/","title":"W3C PROV Provenance Standard","text":"<p>W3C PROV formalizes provenance as a causal graph that captures how digital or real-world artifacts are produced, modified, and influenced over time. By expressing the relationships among entities, activities, and agents, PROV provides a common framework for tracing lineage, validating data integrity, and supporting auditability across systems. Its simplicity makes it compatible with JSON-based workflows, Linked Data environments, and domain-specific standards such as Civic Interconnect.</p> <p>PROV encourages systems to represent not only what exists but how it came to exist. This enables reproducibility, version tracking, trust assessment, and rigorous reasoning about the origins and transformations of information.</p> <p>There are three fundamental node types:</p> <ol> <li>Entity - a thing in some state (a dataset version, a file, a record, a JSON document)</li> <li>Activity - something that happens over time (an ingestion process, a transformation, a merge)</li> <li>Agent - something responsible (a human, an organization, a software system)</li> </ol> <p>There are three fundamental relation types:</p> <ul> <li>wasGeneratedBy (Entity wasGeneratedBy Activity)</li> <li>used (Activity used prior Entity)</li> <li>wasAttributedTo (Entity wasAttributedTo Agent)</li> </ul> <p>Agent -&gt; performed  -&gt; Activity -&gt; generated -&gt; Entity</p>"},{"location":"en/reference/w3c-prov/#interface-to-civic-interconnect-civic-exchange-protocol","title":"Interface to Civic Interconnect Civic Exchange Protocol","text":"<p>Civic Interconnect mirrors core PROV concepts:</p> <ul> <li>Entities correspond to CEP Entity Records, Relationship Records, Vocab Terms, and transformed dataset snapshots.</li> <li>Activities map cleanly to CEP ingest steps, validation passes, transformations, merges, exports, and publication workflows.</li> <li>Agents align with CEP attestors, ingestion identities, organizations, and software systems that produce or modify records.</li> </ul> <p>CEP's attestation block functions as a structured, PROV-compatible expression of responsibility and origin, capturing who created or updated a record and under what method. By keeping CEP's entity life cycle parallel to PROV's activity graph, implementations gain a clear, interoperable provenance layer that can integrate with open data catalogs, regulatory reporting systems, and scientific reproducibility frameworks.</p> <p>A PROV-compliant layer would formalize:</p> <ul> <li>which steps are activities</li> <li>which outputs are entities</li> <li>which systems or people are agents</li> <li>and the edges connecting them.</li> </ul>"},{"location":"en/reference/w3c-prov/#prov-components","title":"PROV Components","text":""},{"location":"en/reference/w3c-prov/#prov-dm","title":"PROV-DM","text":"<p>Data Model.  The ontology that defines the conceptual graph (entity, activity, agent, and their relations).</p>"},{"location":"en/reference/w3c-prov/#prov-n","title":"PROV-N","text":"<p>A simple human-readable notation (like Turtle). Good for examples, academic papers.</p>"},{"location":"en/reference/w3c-prov/#prov-o","title":"PROV-O","text":"<p>An RDF/OWL ontology. When we express provenance in Linked Data form, use this.</p>"},{"location":"en/reference/w3c-prov/#prov-json-prov-xml","title":"PROV-JSON / PROV-XML","text":"<p>Concrete serializations. Most practical systems use PROV-JSON.</p>"},{"location":"en/reference/w3c-prov/#prov-ecosystem","title":"PROV Ecosystem","text":"<p>PROV works with:</p>"},{"location":"en/reference/w3c-prov/#1-skos","title":"1. SKOS","text":"<p>A vocabulary framework for controlled terms. CEP vocabularies (entity types, relationship types) reference SKOS mappings.</p>"},{"location":"en/reference/w3c-prov/#1-json-schema-xml-schema","title":"1. JSON Schema / XML Schema","text":"<p>Define shape and validation rules. These are not provenance - they are structure contracts. PROV complements them, it does not replace them.</p>"},{"location":"en/reference/w3c-prov/#3-linked-data-rdf-owl","title":"3. Linked Data / RDF / OWL","text":"<p>Semantic frameworks like PROV-O, for when provenance needs to interoperate on the semantic web.</p>"},{"location":"en/reference/w3c-prov/#4-w3c-verifiable-credentials-vc","title":"4. W3C Verifiable Credentials (VC)","text":"<p>Where attestation comes in. When we attach provenance and add cryptographic signatures, we get VCs. The CEP attestation field is parallel to this, just simplified.</p>"},{"location":"en/reference/w3c-prov/#5-prov-extensions-used-in-scientific-computing","title":"5. PROV extensions used in scientific computing","text":"<p>Like PROV-One (workflow-focused). Used to describe complex multi-step pipelines.</p>"},{"location":"en/reference/w3c-prov/#6-data-catalogs-ckan-dcat","title":"6. Data catalogs (CKAN, DCAT)","text":"<p>Metadata catalogs that can store PROV graphs about datasets. When publishing dataset metadata, DCAT is the companion standard. CKAN is an open source data management system used by US data.gov, the government of Canada, and more. </p>"},{"location":"en/specs/","title":"Civic Exchange Protocol \u2013 Specification Suite","text":"<p>This directory contains the formal specifications that define the core behavior of the Civic Exchange Protocol (CEP). These documents together form the normative foundation for interoperability, reproducibility, and provable identity across all CEP domains (public procurement, campaign finance, corporate registries, environment, education, etc.).</p> <p>The specifications are versioned independently. Each one describes a distinct layer or subsystem of the protocol. Collectively they form the basis for:</p> <ul> <li>canonicalization and hashing,</li> <li>entity and relationship modeling,</li> <li>provenance and c-tags,</li> <li>adapter execution,</li> <li>graph normalization,</li> <li>identity resolution,</li> <li>vocabulary governance.</li> </ul>"},{"location":"en/specs/#ordering-of-specifications","title":"Ordering of specifications","text":"<p>CEP has one primary standard, on which all others depend:</p> <ol> <li>CEC v1 \u2014 Canonical Encoding &amp; Canonicalization    Defines the deterministic rewriting and normalization rules used throughout CEP,    including the canonical JSON form, string canonicalization, field ordering,    and the hashing process that yields <code>verifiableId</code> values.</li> </ol> <p>After CEC, all remaining specs are listed alphabetically. This avoids implying a linear or hierarchical dependency structure, since each layer is designed to be modular and composable.</p>"},{"location":"en/specs/#specification-index-alphabetical-after-cec","title":"Specification Index (Alphabetical After CEC)","text":""},{"location":"en/specs/#canonical-encoding-canonicalization","title":"Canonical Encoding &amp; Canonicalization","text":"<ul> <li>CEC v1   Core deterministic encoding and canonicalization rules.   Required by all other CEP standards.</li> </ul>"},{"location":"en/specs/#remaining-standards-a-z","title":"Remaining Standards (A \u2192 Z)","text":"<ul> <li> <p>AAS v1 \u2014 Adapter Architecture Specification   Defines how raw external data is transformed into CEP domain objects.   Includes adapter manifests, APS compatibility, self-test rules, and   standardized envelope formats.</p> </li> <li> <p>CDIRA v1 \u2014 Cross-Domain Identity Resolution &amp; Attestation   Mechanisms for merging and reconciling entities that appear across   independent domains.   Includes identity graphs, similarity models, evidence weighting,   stable reference construction, and conflict handling.</p> </li> <li> <p>EFS v1 \u2014 Entity Fingerprint Specification   Defines how canonicalized entities produce stable fingerprint inputs   for hashing, including domain-specific and cross-domain fingerprint   modules.   Used to derive <code>verifiableId</code> values across CEP.</p> </li> <li> <p>GIC v1 \u2014 Global Integrity Constraints   Cross-entity and cross-relationship constraints applicable to all CEP   graphs, including jurisdictional closure, relationship validation,   entity type compatibility, and temporal consistency.</p> </li> <li> <p>GNS v1 \u2014 Graph Normalization Specification   Defines how transformed domain records are merged into a coherent,   deduplicated, canonical graph.   Includes node merging rules, relationship normalization,   provenance tracing, and conflict resolution.</p> </li> <li> <p>VGS v1 \u2014 Vocabulary Governance Specification   Defines the structure, lifecycle, and evolution rules of controlled   vocabularies used throughout CEP.   Includes term governance, versioning, SKOS-style mappings, and the   relationship between vocabularies and core schemas.</p> </li> </ul>"},{"location":"en/specs/#how-these-specifications-fit-together","title":"How these specifications fit together","text":"<p>A simplified view:</p> <pre><code>Raw Data (external APIs, files, scrapers)\n       |\n       v\nAAS v1 \u2014 Adapters produce domain objects\n       |\n       v\nCEC v1 \u2014 Canonical encoding + deterministic rewriting\n       |\n       v\nEFS v1 \u2014 Fingerprints \u2192 verifiableId creation\n       |\n       v\nGNS v1 \u2014 Graph normalization + merging\n       |\n       v\nCDIRA v1 \u2014 Cross-domain identity resolution\n       |\n       v\nGIC v1 \u2014 Global integrity checks\n       |\n       v\nVGS v1 \u2014 Controlled terms, domain vocabularies, governance\n</code></pre> <p>Each specification is self-contained but interoperable, ensuring that:</p> <ul> <li>any CEP pipeline is reproducible,</li> <li>every entity has a verifiable cryptographic identity,</li> <li>transformations are audit-ready,</li> <li>graphs remain consistent across domains and over time,</li> <li>vocabulary evolution is stable and governed.</li> </ul>"},{"location":"en/specs/#contributing-versioning","title":"Contributing &amp; Versioning","text":"<p>Every spec:</p> <ul> <li>declares a semantic version (e.g., <code>1.0.0</code>),</li> <li>must document all breaking and non-breaking changes,</li> <li>should include examples, diagrams, and reference implementations when possible.</li> </ul> <p>Proposals for changes follow the CEP Evolution Policy, including:</p> <ul> <li>issue creation,</li> <li>discussion period,</li> <li>review by editors,</li> <li>version increment (minor/patch/major),</li> <li>publication to the specs directory.</li> </ul>"},{"location":"en/specs/aas-v1/","title":"Adapter Algebra Specification (AAS v1)","text":"<p>Version: 1.0.0  </p> <p>Status: Draft  </p> <p>Applies to: All CEP adapters (local, domain, core, envelope)  </p> <p>Purpose: Define a deterministic, compositional algebra of adapters as typed rewriting morphisms between CEP schemas.</p>"},{"location":"en/specs/aas-v1/#1-overview","title":"1. Overview","text":"<p>Adapters are the primary way CEP connects heterogeneous data sources to the canonical CEP representation. Each adapter is a typed rewriting morphism between schemas:</p> <ul> <li>from a source schema (e.g., a CSV layout, an API response, a legacy JSON schema)</li> <li>to a target schema (e.g., a CEP domain record, a core CEP entity, an envelope)</li> </ul> <p>This document defines:</p> <ul> <li>the type signature of adapters  </li> <li>determinism and partiality requirements  </li> <li>composition and identity adapters </li> <li>versioning and provenance requirements</li> </ul> <p>The goal is to ensure that adapter pipelines behave predictably and can be reasoned about as a compositional algebra.</p>"},{"location":"en/specs/aas-v1/#2-adapter-types-and-signatures","title":"2. Adapter Types and Signatures","text":""},{"location":"en/specs/aas-v1/#21-schema-objects","title":"2.1 Schema Objects","text":"<p>Every adapter operates between two schemas:</p> <ul> <li>A source schema <code>S</code></li> <li>A target schema <code>T</code></li> </ul> <p>Schemas are identified by stable URIs:</p> <ul> <li><code>schemaId: string</code> (e.g., <code>https://.../schema/cep.entity.municipality.json</code>)</li> <li><code>schemaVersion: semver</code> (e.g., <code>\"1.0.0\"</code>)</li> </ul> <p>The pair <code>(schemaId, schemaVersion)</code> uniquely identifies a schema.</p>"},{"location":"en/specs/aas-v1/#22-adapter-definition","title":"2.2 Adapter Definition","text":"<p>An adapter <code>A</code> is defined by:</p> <ul> <li><code>adapterId: string</code> (stable identifier, e.g., <code>adapter.us_mn_muni_raw_to_domain_v1</code>)</li> <li><code>adapterVersion: semver</code></li> <li><code>sourceSchemaId: string</code></li> <li><code>sourceSchemaVersion: semver</code></li> <li><code>targetSchemaId: string</code></li> <li><code>targetSchemaVersion: semver</code></li> <li><code>adapterKind: \"local\" | \"domain\" | \"core\" | \"envelope\"</code> (classification)</li> <li>rewrite function:</li> <li><code>A: SourceRecord -&gt; Result&lt;TargetRecord, AdapterError&gt;</code></li> </ul> <p>Conceptually:</p> <pre><code>A : Records(S) \u2192 Records(T) \u222a {AdapterError}\n</code></pre> <p>Adapters are pure functions: for fixed input, they must always return the same output or the same error.</p>"},{"location":"en/specs/aas-v1/#3-determinism-and-partiality","title":"3. Determinism and Partiality","text":""},{"location":"en/specs/aas-v1/#31-determinism","title":"3.1 Determinism","text":"<p>For any given input record x that conforms to sourceSchemaId / sourceSchemaVersion:</p> <p>If A(x) succeeds once, it must succeed always with the same TargetRecord.</p> <p>If A(x) fails, it must always fail with the same AdapterError category.</p> <p>Non-deterministic behavior (e.g., depending on current time, external services, randomness) is not allowed in the core adapter function.</p> <p>If time-dependent or context-dependent behavior is needed (e.g., \u201cnow\u201d), it must be pushed into explicit input fields or handled outside the adapter.</p>"},{"location":"en/specs/aas-v1/#32-partiality","title":"3.2 Partiality","text":"<p>Adapters are generally partial:</p> <ul> <li>Not all SourceRecords are necessarily valid or mappable.</li> <li>Failures must be explicit and typed.</li> </ul> <p>We model this using <code>Result&lt;TargetRecord, AdapterError&gt;</code>.</p> <p>AdapterError categories include (but are not limited to):</p> <ul> <li>SchemaViolation (input does not conform to the declared source schema)</li> <li>MissingRequiredField</li> <li>InvalidCode (unknown vocabulary term)</li> <li>CanonicalizationFailure</li> <li>InconsistentIdentifiers</li> <li>UnsupportedVersion</li> <li>InternalInvariantViolation (bug, not data issue)</li> </ul> <p>Adapters must not silently correct or drop records without either:</p> <ul> <li>returning an explicit error, or</li> <li>recording warnings in an attested envelope.</li> </ul>"},{"location":"en/specs/aas-v1/#4-composition-of-adapters","title":"4. Composition of Adapters","text":"<p>Given adapters:</p> <p><code>A: S \u2192 T</code></p> <p><code>B: T \u2192 U</code></p> <p>We can form a composite adapter:</p> <p><code>B \u2218 A : S \u2192 U</code></p> <p>defined by:</p> <pre><code>(B \u2218 A)(x) = \n    match A(x) with\n      | Ok(y)    -&gt; B(y)\n      | Error(e) -&gt; Error(e)\n</code></pre> <p>4.1 Associativity</p> <p>Composition of adapters is associative:</p> <p><code>C \u2218 (B \u2218 A) = (C \u2218 B) \u2218 A</code></p> <p>at the level of the underlying functions, provided they all share compatible schemas and error semantics.</p> <p>This means adapter pipelines behave like morphisms in a category:</p> <ul> <li>Objects: schemas (schemaId, schemaVersion)</li> <li>Morphisms: adapters between schemas</li> </ul>"},{"location":"en/specs/aas-v1/#42-identity-adapters","title":"4.2 Identity Adapters","text":"<p>For every schema (S, v), there MUST exist an identity adapter:</p> <p><code>id_S : S \u2192 S</code></p> <p>such that for all adapters <code>A: S \u2192 T</code> and <code>B: U \u2192 S</code>:</p> <p><code>A \u2218 id_S = A</code></p> <p><code>id_S \u2218 B = B</code></p> <p>The identity adapter performs validation but no transformation:</p> <ul> <li>It may enforce schema conformance.</li> <li>It must not change any field value.</li> </ul>"},{"location":"en/specs/aas-v1/#43-version-aware-composition","title":"4.3 Version-Aware Composition","text":"<p>Adapters are tied to specific (schemaId, schemaVersion) pairs.</p> <p>Composition <code>B \u2218 A</code> is only valid if:</p> <ul> <li><code>A.targetSchemaId == B.sourceSchemaId</code></li> <li><code>A.targetSchemaVersion</code> is compatible with <code>B.sourceSchemaVersion</code></li> </ul> <p>Compatibility rules must be explicit:</p> <ul> <li>Exact match, or</li> <li>Declared compatibility ranges (e.g., &gt;=1.0.0 &lt;2.0.0)</li> </ul> <p>If versions are incompatible, composition is not allowed without an explicit version-bridge adapter.</p>"},{"location":"en/specs/aas-v1/#5-adapter-kinds-and-pipelines","title":"5. Adapter Kinds and Pipelines","text":"<p>Adapters are grouped into kinds to reflect their typical position in a pipeline:</p> <ul> <li> <p>Local adapters: Source-specific \u2192 domain-specific raw</p> </li> <li> <p>Domain adapters: Domain-specific raw \u2192 CEP domain record</p> </li> <li> <p>Core adapters: CEP domain record \u2192 CEP core entity/relationship</p> </li> <li> <p>Envelope adapters: CEP core entity/relationship \u2192 exchange/envelope</p> </li> </ul> <p>A typical pipeline:</p> <pre><code>RawSource\n  \u2192 (Local Adapter)\nDomainRaw\n  \u2192 (Domain Adapter)\nDomainEntity\n  \u2192 (Core Adapter)\nCoreEntity\n  \u2192 (Envelope Adapter)\nEnvelope\n</code></pre> <p>Each step is a morphism of schemas; the full pipeline is the composite morphism.</p>"},{"location":"en/specs/aas-v1/#6-rewriting-semantics","title":"6. Rewriting Semantics","text":"<p>Adapters are typed rewriting functions:</p> <ul> <li>They rewrite structures (records), not just strings.</li> <li>They apply the canonicalization pipeline to relevant fields.</li> <li>They enforce vocabulary mappings and schema constraints.</li> </ul> <p>The adapter algebra is therefore:</p> <ul> <li>structural at the record level</li> <li>compositional under function composition</li> <li>strategy-governed in terms of pipeline order (we do not assume commutativity)</li> </ul>"},{"location":"en/specs/aas-v1/#7-versioning-of-adapters","title":"7. Versioning of Adapters","text":"<p>Each adapter has an explicit adapterVersion (SemVer):</p> <ul> <li>MAJOR: breaking change in output schema or semantics.</li> <li>MINOR: backward-compatible enhancements (additional computed fields, new optional behavior).</li> <li>PATCH: bugfixes that preserve behavior for valid inputs.</li> </ul> <p>Every produced record MUST include:</p> <ul> <li>adapterId</li> <li>adapterVersion</li> </ul> <p>in its provenance / envelope, so that downstream processes and verifiers can reproduce or audit adapter behavior.</p>"},{"location":"en/specs/aas-v1/#8-equivalence-of-adapters","title":"8. Equivalence of Adapters","text":"<p>Two adapters <code>A, B: S \u2192 T</code> are extensionally equivalent if for all valid inputs <code>x</code>:</p> <p><code>A(x) = B(x)</code></p> <p>CEP may treat extensionally equivalent adapters as interchangeable, but they may still differ in:</p> <ul> <li>implementation language</li> <li>performance</li> <li>internal logging or diagnostics</li> </ul> <p>Equivalence is a conceptual notion; practical systems may use tests to approximate it.</p>"},{"location":"en/specs/aas-v1/#9-adapter-provenance-and-attestation","title":"9. Adapter Provenance and Attestation","text":"<p>Adapters are central to trust in CEP data. Therefore:</p> <p>Every adapter invocation SHOULD be recorded in provenance:</p> <ul> <li>adapterId</li> <li>adapterVersion</li> <li>timestamps</li> <li>success or failure</li> </ul> <p>Cryptographic tags (CTags) SHOULD commit to:</p> <ul> <li>adapter identity and version</li> <li>input fingerprint (if applicable)</li> <li>canonical output representation (CEC)</li> </ul> <p>This allows verifiers to:</p> <ul> <li>reconstruct the adapter chain,</li> <li>reproduce transformations,</li> <li>detect tampering or missing pipeline steps.</li> </ul>"},{"location":"en/specs/aas-v1/#10-summary","title":"10. Summary","text":"<p>The adapter algebra defines a category of schemas and adapters:</p> <ul> <li>Objects: versioned schemas</li> <li>Morphisms: deterministic, typed, possibly partial adapters</li> <li>Composition: associative function composition</li> <li>Identities: schema-preserving validators</li> </ul> <p>This algebra underpins cross-domain interoperability, reproducible pipelines, and verifiable transformations in CEP.</p>"},{"location":"en/specs/cdira-v1/","title":"Cross-Domain Identity Resolution Algorithm (CDIRA v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: All CEP entities across all domains (campaign finance, environment, education, municipal, etc.)</p> <p>Purpose: Define a deterministic algorithm for resolving when multiple CEP entities (possibly from different domains or sources) represent the same real-world entity.</p>"},{"location":"en/specs/cdira-v1/#1-overview","title":"1. Overview","text":"<p>CEP treats identity as a minimal, canonical fingerprint (EFS v1) plus a rewriting-based normalization strategy. Cross-domain identity resolution is the process of:</p> <ul> <li>detecting when multiple CEP entities refer to the same real entity,</li> <li>assigning them to a shared identity cluster, and</li> <li>ensuring that this process is deterministic, auditable, and versioned.</li> </ul> <p>The Cross-Domain Identity Resolution Algorithm (CDIRA) defines:</p> <ol> <li>The evidence model for identity.</li> <li>The deterministic resolution steps (candidate generation, evidence evaluation, cluster assignment).</li> <li>The relationship between fingerprints, graphs, and identity clusters.</li> <li>Versioning and provenance requirements for the resolution process.</li> </ol> <p>CDIRA is a rewriting system over entity graphs: it rewrites sets of entity nodes into equivalence classes (identity clusters) using strategy-governed rules.</p>"},{"location":"en/specs/cdira-v1/#2-identity-model","title":"2. Identity Model","text":"<p>CDIRA operates on CEP entities that already satisfy:</p> <ul> <li>canonicalization (names, identifiers, vocabularies),</li> <li>fingerprint specification (EFS v1),</li> <li>canonical encoding (CEC v1),</li> <li>graph normalization (GNS v1) where applicable.</li> </ul>"},{"location":"en/specs/cdira-v1/#21-identity-units","title":"2.1 Identity Units","text":"<p>An Identity Unit is a single CEP entity with:</p> <ul> <li>verifiableId</li> <li>fingerprint (EFS object)</li> <li>domain-specific payload</li> <li>provenance</li> </ul>"},{"location":"en/specs/cdira-v1/#22-identity-cluster","title":"2.2 Identity Cluster","text":"<p>An Identity Cluster is a non-empty set of Identity Units believed to refer to the same real-world entity.</p> <p>Each cluster has:</p> <ul> <li>clusterId (stable identifier, see Section 7)</li> <li>members: list of verifiableIds</li> <li>clusterFingerprint: optional aggregated fingerprint summary</li> <li>cdiraVersion: version of the resolution algorithm used</li> <li>provenance for how and when it was formed</li> </ul>"},{"location":"en/specs/cdira-v1/#3-evidence-model","title":"3. Evidence Model","text":"<p>CDIRA uses deterministic, rule-based evidence classes. No probabilistic black-box logic is required in the core spec (implementations may use statistical methods internally, but final decisions must be reproducible).</p> <p>Evidence is grouped into:</p> <ul> <li>Strong evidence</li> <li>Moderate evidence</li> <li>Weak evidence</li> </ul>"},{"location":"en/specs/cdira-v1/#31-strong-evidence","title":"3.1 Strong Evidence","text":"<p>Strong evidence is sufficient to treat two entities as identical:</p> <ul> <li>Exact fingerprint match (same EFS fingerprint, same verifiableId).</li> <li>Shared authoritative identifier under a globally trusted scheme:<ul> <li>same SNFEI, LEI, FEC ID, EPA Facility ID, IPEDS ID, national corporate registry ID, etc., after canonicalization.</li> </ul> </li> </ul> <p>If strong evidence is present, entities must be placed in the same cluster.</p>"},{"location":"en/specs/cdira-v1/#32-moderate-evidence","title":"3.2 Moderate Evidence","text":"<p>Moderate evidence suggests likely identity but is not self-sufficient:</p> <ul> <li>Same canonical name + same jurisdictionUri + same entityTypeUri.</li> <li>Same canonical name + shared external identifier from a mid-confidence registry.</li> <li>Name equivalence plus matching normalized attributes that are relatively stable.</li> </ul> <p>Moderate evidence may trigger clustering if no conflicting evidence exists.</p>"},{"location":"en/specs/cdira-v1/#33-weak-evidence","title":"3.3 Weak Evidence","text":"<p>Weak evidence by itself must not cause a merge:</p> <ul> <li>co-occurrence patterns (same officers, same addresses),</li> <li>shared phone or email,</li> <li>similar but not identical names,</li> <li>proximity in graph structure.</li> </ul> <p>Weak evidence is only used to support moderate evidence or break ties.</p>"},{"location":"en/specs/cdira-v1/#4-deterministic-resolution-strategy","title":"4. Deterministic Resolution Strategy","text":"<p>CDIRA defines a three-phase resolution pipeline:</p> <ol> <li>Candidate Generation</li> <li>Evidence Evaluation</li> <li>Cluster Assignment</li> </ol>"},{"location":"en/specs/cdira-v1/#41-candidate-generation","title":"4.1 Candidate Generation","text":"<p>Candidate generation finds potential matches but does not decide identity.</p> <p>Blocking keys (deterministic):</p> <ul> <li>Identifier-based blocks: entities sharing a canonical value under any identifier scheme.</li> <li>Name + jurisdiction blocks: same legalNameNormalized AND same jurisdictionUri.</li> <li>Domain-specific blocks: e.g., same IPEDS ID, same EPA Registry ID, same FEC ID.</li> </ul> <p>Within each block, consider all unordered pairs as candidates.</p>"},{"location":"en/specs/cdira-v1/#42-evidence-evaluation","title":"4.2 Evidence Evaluation","text":"<p>For each candidate pair (A, B):</p> <ol> <li>Collect evidence of all types.</li> <li>Apply rules in order:</li> </ol>"},{"location":"en/specs/cdira-v1/#rule-1-fingerprint-equality","title":"Rule 1 (Fingerprint Equality).","text":"<p>If A.verifiableId == B.verifiableId, they must be in the same cluster.</p>"},{"location":"en/specs/cdira-v1/#rule-2-strong-identifier-equality","title":"Rule 2 (Strong Identifier Equality).","text":"<p>If they share an authoritative identifier and no explicit conflict exists, they must be merged.</p>"},{"location":"en/specs/cdira-v1/#rule-3-moderate-evidence-rule","title":"Rule 3 (Moderate Evidence Rule).","text":"<p>If:</p> <ul> <li>names, jurisdiction, and entity type match,</li> <li>no contradictory identifier evidence exists,</li> <li>one or more moderate evidence conditions hold,</li> </ul> <p>then A and B should be clustered.</p>"},{"location":"en/specs/cdira-v1/#rule-4-conflict-rule","title":"Rule 4 (Conflict Rule).","text":"<p>If strong identifiers match but identity-defining attributes contradict domain rules, they must not be auto-merged. Emit a conflict record.</p>"},{"location":"en/specs/cdira-v1/#rule-5-default-non-merge","title":"Rule 5 (Default Non-Merge).","text":"<p>If weak evidence only, entities remain separate.</p>"},{"location":"en/specs/cdira-v1/#43-cluster-assignment","title":"4.3 Cluster Assignment","text":"<p>Clusters are formed using transitive closure:</p> <p>If A merges with B, and B merges with C, then all three belong to the same cluster unless forbidden by a conflict rule.</p> <p>Cluster construction is deterministic given:</p> <ul> <li>same input entities,</li> <li>same version tuple,</li> <li>same configuration.</li> </ul>"},{"location":"en/specs/cdira-v1/#5-cdira-as-a-rewriting-system","title":"5. CDIRA as a Rewriting System","text":"<p>Conceptually, CDIRA:</p> <ul> <li>Starts from singleton clusters <code>{A}, {B}, {C}, ...</code></li> <li>Applies merge rewrites based on evidence rules:<ul> <li><code>{A}, {B} \u2192 {A,B}</code></li> </ul> </li> <li>Produces a partition of the entity set.</li> </ul> <p>The merge operation is:</p> <ul> <li>associative,</li> <li>idempotent (re-running CDIRA on identical clusters produces no changes).</li> </ul> <p>The internal merge process need not be commutative; the resulting partition must be independent of evaluation order.</p>"},{"location":"en/specs/cdira-v1/#6-conflict-handling","title":"6. Conflict Handling","text":"<p>CDIRA must produce explicit artifacts for:</p> <ul> <li>conflicting strong identifiers,</li> <li>inconsistent identity-defining attributes,</li> <li>ambiguous clusters with insufficient evidence.</li> </ul> <p>Conflicts are recorded as:</p> <pre><code>{\n  \"conflictType\": \"IdentifierConflict\" | \"FingerprintConflict\" | \"AmbiguousCluster\",\n  \"entities\": [\"verifiableId1\", \"verifiableId2\", \"...\"],\n  \"evidence\": {\n    \"strong\": [],\n    \"moderate\": [],\n    \"weak\": []\n  },\n  \"cdiraVersion\": \"1.0.0\",\n  \"timestamp\": \"...\",\n  \"resolutionStatus\": \"unresolved\" | \"manuallyResolved\" | \"ignored\"\n}\n</code></pre> <p>These become part of provenance and may be resolved later.</p>"},{"location":"en/specs/cdira-v1/#7-cluster-identifiers","title":"7. Cluster Identifiers","text":"<p>Each Identity Cluster receives a stable clusterId.</p> <p>Two allowed strategies:</p> <ol> <li> <p>Derived clusterId (hash-based):</p> </li> <li> <p>Deterministic hash of:</p> <ul> <li>sorted member verifiableIds</li> <li>version tuple</li> </ul> </li> <li> <p>Externally assigned clusterId:</p> </li> <li> <p>Used when authoritative registries assign persistent IDs.</p> </li> </ol> <p>In both cases:</p> <p><code>clusterId = \"cep-cluster:\" || base64url( H( clusterSummary ) )</code></p> <p>Where clusterSummary is a CEC-serialized object including:</p> <ul> <li>sorted member IDs</li> <li>version tuple</li> <li>optional clusterFingerprint</li> </ul>"},{"location":"en/specs/cdira-v1/#8-versioning-and-provenance","title":"8. Versioning and Provenance","text":"<p>CDIRA is versioned:</p> <p><code>cdiraVersion: 1.0.0</code></p> <p>Every cluster and conflict record must include:</p> <pre><code>{\n    \"cdiraVersion\": \"1.0.0\",\n    \"versions\": {\n        \"cec\": \"...\",\n        \"fingerprint\": \"...\",\n        \"schema\": \"...\",\n        \"vocabulary\": {},\n        \"adapter\": \"...\",\n        \"gns\": \"...\"\n    }\n}\n</code></pre> <p>Identity resolution is a provenance activity:</p> <ul> <li>identityResolverId</li> <li>identityResolverVersion</li> <li>timestamp</li> <li>input sets (entity IDs)</li> <li>output clusters and conflicts</li> </ul> <p>This ensures auditability and reproducibility.</p>"},{"location":"en/specs/cdira-v1/#9-determinism-requirements","title":"9. Determinism Requirements","text":"<p>CDIRA must be deterministic:</p> <p>Given the same inputs, versions, and configuration, the resulting clusters and conflicts must be identical.</p> <p>Any use of probabilistic or heuristic methods must:</p> <ul> <li>produce deterministic outputs (e.g., fixed seeds), or</li> <li>be advisory only, not part of final merge decisions.</li> </ul>"},{"location":"en/specs/cdira-v1/#10-summary","title":"10. Summary","text":"<p>CDIRA v1 defines:</p> <ul> <li>a rule-based deterministic approach to cross-domain identity resolution</li> <li>an evidence model (strong, moderate, weak)</li> <li>a rewrite system forming clusters via merge operations</li> <li>explicit conflict handling</li> <li>stable cluster identifiers</li> <li>full versioning and provenance for identity decisions</li> </ul> <p>This specification ties together canonicalization (CEC), fingerprints (EFS), graph normalization (GNS), and adapter semantics (AAS) into a coherent, cross-domain identity resolution framework for CEP.</p>"},{"location":"en/specs/cec-v1/","title":"CEC v1 - Canonical Encoding for CEP","text":"<p>Status: Draft</p> <p>Version: 1.0.0</p> <p>Applies to: CEP Entities, Relationships, Envelopes, CTags</p> <p>Purpose: Ensure deterministic, cross-system, cross-version hashing and verification.</p>"},{"location":"en/specs/cec-v1/#1-overview","title":"1. Overview","text":"<p>CEC (Canonical Encoding for CEP) defines a deterministic, language-independent serialization format for all CEP records. It ensures that two semantically identical CEP structures produce identical byte sequences and therefore identical cryptographic tags.</p> <p>CEC does not replace JSON, but defines the rules for turning a CEP structure into a canonical JSON byte representation.</p> <p>CEC is versioned independently of CEP schemas and vocabularies.</p>"},{"location":"en/specs/cec-v1/#2-goals","title":"2. Goals","text":"<ul> <li>Deterministic across programming languages</li> <li>Deteministic across CEP versions</li> <li>Hash-stable</li> <li>Independent of in-memory ordering</li> <li>Immune to whitespace or pretty-printing differences</li> <li>Explicit about versioning</li> <li>Backwards compatible via declared CEC version</li> </ul>"},{"location":"en/specs/cec-v1/#3-canonicalization-pipeline","title":"3. Canonicalization Pipeline","text":"<p>CEC requires that the following pipeline be applied after CEP canonicalization and before hashing:</p> <p>CEP.Normalization \u2192 CEC.Serialization \u2192 hash()</p> <p>Where:</p> <ul> <li>CEP.Normalization = rewrite pipeline (canonical names, vocabulary terms, identifiers, units, etc.)</li> <li>CEC.Serialization = deterministic JSON encoding defined in this document</li> </ul>"},{"location":"en/specs/cec-v1/#4-canonical-serialization-rules","title":"4. Canonical Serialization Rules","text":""},{"location":"en/specs/cec-v1/#41-key-ordering-deterministic-lexicographic-order","title":"4.1 Key Ordering (Deterministic Lexicographic Order)","text":"<ul> <li>All JSON object keys must be sorted lexicographically by Unicode code point, ascending.</li> <li>Sorting is stable.</li> <li>No domain-specific exceptions.</li> </ul> <p>Example: <code>{\"b\":1, \"a\":2}</code> becomes:</p> <p><code>{\"a\":2,\"b\":1}</code></p>"},{"location":"en/specs/cec-v1/#42-whitespace","title":"4.2 Whitespace","text":"<ul> <li>No whitespace except where required by JSON string literals.</li> <li>No pretty printing.</li> <li>No indentation.</li> <li>No newline required at end of file.</li> </ul> <p>CEC is optimized for hashing, not for readability.</p>"},{"location":"en/specs/cec-v1/#43-null-and-empty-field-omission-rules","title":"4.3 Null and Empty Field Omission Rules","text":"<p>To avoid non-determinism:</p> <ul> <li>Fields with value null MUST be omitted entirely.</li> <li>Empty arrays MUST be encoded as [] (not omitted).</li> <li>Empty objects MUST be encoded as {} (not omitted).</li> </ul> <p>Reason: presence/absence of an empty list has semantic meaning; null does not.</p>"},{"location":"en/specs/cec-v1/#44-numeric-normalization","title":"4.4 Numeric Normalization","text":"<p>Rules:</p> <ol> <li>No scientific notation.</li> <li>No trailing zeros after decimal.</li> <li>No + sign.</li> <li><code>-0</code> must be encoded as <code>0</code>.</li> <li>Integers and floats share the same normalization rules.</li> </ol> <p>Examples:</p> <pre><code>1.0    \u2192 1\n01.50  \u2192 1.5\n-0.000 \u2192 0\n</code></pre>"},{"location":"en/specs/cec-v1/#45-string-normalization","title":"4.5 String Normalization","text":"<ul> <li>All strings must be Unicode NFC after canonicalization.</li> <li>Escaping rules follow RFC8259 strictly.</li> <li>No control characters except via escape sequences.</li> </ul>"},{"location":"en/specs/cec-v1/#46-boolean-normalization","title":"4.6 Boolean Normalization","text":"<p>Booleans are always:</p> <pre><code>true\nfalse\n</code></pre> <p>(lowercase, ASCII).</p>"},{"location":"en/specs/cec-v1/#47-list-normalization","title":"4.7 List Normalization","text":"<p>Lists may be:</p> <ul> <li>order-preserving if the schema defines semantic order</li> <li>sorted lexicographically if order is not semantically meaningful</li> <li>CEC requires each schema field to declare:</li> </ul> <pre><code>\"ordering\": \"preserved\" | \"sorted\"\n</code></pre> <p>Default = <code>\"preserved\"</code>.</p>"},{"location":"en/specs/cec-v1/#48-deterministic-representation-of-nested-structures","title":"4.8 Deterministic Representation of Nested Structures","text":"<p>All rules apply recursively.</p>"},{"location":"en/specs/cec-v1/#5-canonical-envelope-structure-required-metadata","title":"5. Canonical Envelope Structure (Required Metadata)","text":"<p>Every CEP object that participates in hashing MUST include:</p> <ul> <li>\"cecVersion\" \u2014 version string (e.g., \"1.0.0\").</li> <li>\"schemaVersion\" \u2014 version of the CEP schema used.</li> <li>\"vocabularyVersion\" \u2014 list or mapping of vocab versions used.</li> <li>\"adapterVersion\" \u2014 version of the adapter that produced the record.</li> </ul> <p>This ensures hashes remain interpretable even as schemas change.</p>"},{"location":"en/specs/cec-v1/#6-versioning-rules-formal-versioning-structure","title":"6. Versioning Rules (Formal Versioning Structure)","text":"<p>CEC itself must be versioned using SemVer:</p> <ul> <li>MAJOR: breaking changes</li> <li>MINOR: behavior additions that preserve determinism</li> <li>PATCH: clarifications or typo fixes</li> </ul> <p>Every CEP structure hashed MUST include:</p> <ul> <li>\"cecVersion\" \u2014 the version used to transform it into bytes</li> <li>\"schemaVersion\" \u2014 because schemas change</li> <li>\"vocabularyVersion\" \u2014 because vocabularies evolve</li> <li>\"adapterVersion\" \u2014 because adapter logic changes</li> </ul> <p>Guaranteed Property:</p> <p>For any fixed {cecVersion, schemaVersion, vocabularyVersion, adapterVersion}, the hash of a CEP structure is deterministic across all implementations.</p> <p>This is the backbone of verifiable civic data.</p>"},{"location":"en/specs/cec-v1/#7-example-canonical-byte-representation","title":"7. Example Canonical Byte Representation","text":"<p>Input structure:</p> <pre><code>{\n    \"legalName\": \"City of Springfield\",\n    \"identifiers\": {\n        \"snfei\": { \"value\": \"abc123\" },\n        \"localId\": null\n    },\n    \"status\": { \"statusCode\": \"ACTIVE\", \"statusEffectiveDate\": \"1900-01-01\" }\n}\n</code></pre> <p>After CEP canonicalization \u2192 CEC v1 serialization:</p> <pre><code>{\n    \"cecVersion\": \"1.0.0\",\n    \"identifiers\": { \"snfei\": { \"value\": \"abc123\" } },\n    \"legalName\": \"City of Springfield\",\n    \"status\": { \"statusCode\": \"ACTIVE\", \"statusEffectiveDate\": \"1900-01-01\" }\n}\n</code></pre> <p>Observe:</p> <ul> <li>keys sorted</li> <li>null field removed</li> <li>minimal whitespace</li> <li>no formatting differences</li> </ul>"},{"location":"en/specs/efs-v1/","title":"Entity Fingerprint Specification (EFS v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: All CEP Entity types across all civic domains</p> <p>Purpose: Define a deterministic, minimal, cross-domain identity model for civic entities.</p>"},{"location":"en/specs/efs-v1/#1-overview","title":"1. Overview","text":"<p>The Entity Fingerprint Specification (EFS) defines the minimal set of canonical features that uniquely identify an entity within CEP. The fingerprint:</p> <ul> <li>is derived after canonicalization (rewriting),</li> <li>is serialized using CEC v1,</li> <li>is hashed to produce the verifiableId,</li> <li>remains stable across domains, sources, adapters, and time.</li> </ul> <p>The fingerprint is domain-agnostic, strategy-governed, and minimal \u2014 no descriptive or non-identity metadata is included.</p>"},{"location":"en/specs/efs-v1/#2-goals","title":"2. Goals","text":"<p>The fingerprint must:</p> <ul> <li>produce identical results across all implementations</li> <li>be stable across adapter versions (unless identity rules change)</li> <li>be independent of source formatting</li> <li>be invariant under non-identity attribute changes (e.g., address, status, phone number)</li> <li>support cross-domain deduplication and linking</li> <li>encode only essential identity-defining attributes</li> </ul> <p>The fingerprint is not a record; it is an identity contract.</p>"},{"location":"en/specs/efs-v1/#3-canonical-fingerprint-object-structure","title":"3. Canonical Fingerprint Object Structure","text":"<p>Every CEP Entity must generate a fingerprint object of the form:</p> <pre><code>{\n    \"entityTypeUri\": \"&lt;URI&gt;\",\n    \"jurisdictionFingerprint\": \"&lt;object | null&gt;\",\n    \"identifierFingerprint\": \"&lt;object&gt;\",\n    \"nameFingerprint\": \"&lt;object&gt;\",\n    \"schemaVersion\": \"&lt;semver&gt;\",\n    \"vocabularyVersion\": \"&lt;mapping of vocab domains&gt;\",\n    \"fingerprintVersion\": \"1.0.0\"\n}\n</code></pre> <p>This object is then CEC-serialized and hashed, yielding:</p> <p><code>verifiableId = CTag(hash(CEC(fingerprintObject)))</code></p> <p>Each sub-fingerprint is defined below.</p>"},{"location":"en/specs/efs-v1/#4-identifier-fingerprint-required","title":"4. Identifier Fingerprint (Required)","text":"<p>Identifiers are the strongest signal of identity.</p> <p>Rules:</p> <ol> <li> <p>Each entityType defines a list of primary identifier schemes    (e.g.,</p> </li> <li> <p>SNFEI (CEP universal entity ID),</p> </li> <li>FEC committee ID,</li> <li>EPA facility ID,</li> <li>IPEDS institution ID,</li> <li>LEI for legal entities,</li> <li> <p>National corporate registry IDs).</p> </li> <li> <p>The fingerprint MUST include all canonical identifiers available, after rewriting.</p> </li> <li> <p>Identifiers MUST be represented as:</p> </li> </ol> <pre><code>{\n    \"&lt;scheme&gt;\": \"&lt;canonicalValue&gt;\"\n}\n</code></pre> <p>4.Identifiers are sorted by key lexicographically (CEC rule).</p> <ol> <li>Absent identifiers are omitted, not null.</li> </ol> <p>Example:</p> <pre><code>{\n    \"snfei\": \"34486b...\",\n    \"fecId\": \"C12345678\"\n}\n</code></pre>"},{"location":"en/specs/efs-v1/#5-name-fingerprint-required-for-entities-with-names","title":"5. Name Fingerprint (Required for entities with names)","text":"<p>Names are rewritten using the full CEP canonicalization pipeline:</p> <ul> <li> <p>lowercase,</p> </li> <li> <p>uniform spacing,</p> </li> <li> <p>punctuation removal (post abbreviation expansion),</p> </li> <li> <p>locale-aware handling of accronyms / corporate forms,</p> </li> <li> <p>Unicode NFC.</p> </li> </ul> <p>The fingerprint includes:</p> <pre><code>{\n    \"legalNameNormalized\": \"&lt;string&gt;\"\n}\n</code></pre> <p>For individuals, this becomes:</p> <pre><code>{\n    \"familyName\": \"...\",\n    \"givenName\": \"...\",\n    \"additionalNames\": \"...\",\n    \"normalizedFullName\": \"...\"\n}\n</code></pre> <p>Names are generally weaker evidence than identifiers but essential when identifiers are missing or unreliable.</p>"},{"location":"en/specs/efs-v1/#6-jurisdiction-fingerprint-optional-but-recommended","title":"6. Jurisdiction Fingerprint (Optional but Recommended)","text":"<p>Many civic entities only make sense within a jurisdictional context (cities, counties, permits, schools, etc.).</p> <p>If the entity has a jurisdiction:</p> <pre><code>{\n    \"jurisdictionUri\": \"&lt;canonical URI&gt;\"\n}\n</code></pre> <p>If jurisdiction is not applicable, then omit.</p>"},{"location":"en/specs/efs-v1/#7-what-is-not-allowed-in-the-fingerprint","title":"7. What is not allowed in the fingerprint","text":"<p>Fingerprint must exclude:</p> <ul> <li>addresses</li> <li>dates</li> <li>statuses</li> <li>revision numbers</li> <li>descriptions</li> <li>contact information</li> <li>provenance</li> <li>relationships</li> <li>email, phone, geo</li> <li>filing history</li> <li>members / officers / associates</li> </ul> <p>These are attributes, not identity.</p> <p>This strict minimalism is what prevents identity drift over time.</p>"},{"location":"en/specs/efs-v1/#8-determinism-requirements","title":"8. Determinism Requirements","text":"<p>The fingerprint MUST be:</p> <ul> <li>constructed after canonicalization</li> <li>stable across all platforms</li> <li>CEC-serialized</li> <li>independent of representation or ordering</li> <li>stable across descriptive changes</li> <li>variant only if identity-defining attributes change</li> </ul> <p>Example:</p> <p>If a municipality changes its address or mayor, the entity's fingerprint stays the same.</p>"},{"location":"en/specs/efs-v1/#9-fingerprint-versioning-formal-versioning-structure","title":"9. Fingerprint Versioning (Formal Versioning Structure)","text":"<p>Fingerprint rules evolve slowly and must be versioned explicitly.</p> <p>Each fingerprint includes:</p> <pre><code>\"fingerprintVersion\": \"1.0.0\"\n</code></pre> <p>Semantic versioning rules:</p> <ul> <li>MAJOR: changes to identity rules (breaking identity linkage)</li> <li>MINOR: addition of optional fingerprint components</li> <li>PATCH: clarifications or bugfixes</li> </ul> <p>Every hashed verifiableId implicitly commits to:</p> <ul> <li>CEC version</li> <li>Schema version</li> <li>Vocabulary version(s)</li> <li>Fingerprint version</li> </ul> <p>This ensures verifiers can always interpret a fingerprint from any year.</p>"},{"location":"en/specs/efs-v1/#10-example-fingerprint-object-municipality","title":"10. Example Fingerprint Object (Municipality)","text":"<p>Before hashing:</p> <pre><code>{\n    \"entityTypeUri\": \"https://\u2026/entity-type/municipality\",\n    \"jurisdictionFingerprint\": { \"jurisdictionUri\": \"US-IL\" },\n    \"identifierFingerprint\": {\n        \"snfei\": \"34486b...ca5b3\"\n    },\n    \"nameFingerprint\": {\n        \"legalNameNormalized\": \"city of springfield\"\n    },\n    \"schemaVersion\": \"1.0.0\",\n    \"vocabularyVersion\": { \"entityType\": \"1.0.0\" },\n    \"fingerprintVersion\": \"1.0.0\"\n}\n</code></pre> <p>CEC \u2192 hash \u2192 CTag \u2192 verifiableId.</p>"},{"location":"en/specs/efs-v1/#multiple-domains-one-fingerprint-system","title":"Multiple Domains, One Fingerprint System","text":"<ul> <li>Campaign finance \u2192 donors, committees</li> <li>Environmental \u2192 facilities, permits</li> <li>Education \u2192 institutions, programs</li> </ul> <p>All of them use the exact same fingerprint structure.</p> <p>Only the content varies.</p> <p>This unifies CEP across domains and ensures cross-domain linkability.</p>"},{"location":"en/specs/gic-v1/","title":"Global Integrity Constraints (GIC v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: All CEP entities, relationships, provenance graphs, adapters, and envelopes</p> <p>Purpose: Define system-wide invariants that must hold for CEP data to be valid, canonicalizable, interoperable, and verifiable.</p>"},{"location":"en/specs/gic-v1/#1-overview","title":"1. Overview","text":"<p>The Civic Exchange Protocol (CEP) unifies multiple rewriting systems across domains (canonicalization, adapters, fingerprints, provenance, graph merging, and hashing). Global Integrity Constraints (GIC) define the cross-cutting rules that govern all CEP data and transformations. They ensure that:</p> <ul> <li>identities remain stable and non-ambiguous</li> <li>relationships are consistent and well-formed</li> <li>provenance is coherent and auditable</li> <li>graph normalization yields deterministic results</li> <li>CTags and fingerprints remain trustworthy</li> <li>versioning is explicit and reproducible</li> </ul> <p>These constraints are mandatory. Any violation indicates an invalid record, invalid adapter output, or corrupted graph.</p>"},{"location":"en/specs/gic-v1/#2-identity-integrity-constraints","title":"2. Identity Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#21-unique-verifiable-identifier","title":"2.1 Unique Verifiable Identifier","text":"<p>Every entity MUST have exactly one <code>verifiableId</code>, produced via:</p> <ol> <li>canonicalization</li> <li>fingerprint construction</li> <li>CEC encoding</li> <li>cryptographic hashing</li> </ol> <p><code>verifiableId</code> MUST be globally unique for entities with distinct fingerprints.</p>"},{"location":"en/specs/gic-v1/#22-stability-under-attribute-change","title":"2.2 Stability Under Attribute Change","text":"<p>An entity's <code>verifiableId</code> MUST remain unchanged if:</p> <ul> <li>addresses change</li> <li>phone/email change</li> <li>officers or membership change</li> <li>descriptive fields change</li> <li>statuses change (ACTIVE \u2192 INACTIVE)</li> </ul> <p>Only identity-defining attributes may influence the fingerprint.</p>"},{"location":"en/specs/gic-v1/#23-deterministic-cross-domain-identity","title":"2.3 Deterministic Cross-Domain Identity","text":"<p>If entity A in one domain and entity B in another are representing the same real-world entity, then their fingerprints MUST normalize to the same value. If fingerprints differ, entities MUST be treated as distinct.</p>"},{"location":"en/specs/gic-v1/#3-relationship-integrity-constraints","title":"3. Relationship Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#31-referential-integrity","title":"3.1 Referential Integrity","text":"<p>All relationships MUST reference existing entities using their canonical verifiableId. No relationship may point to a:</p> <ul> <li>blank/empty ID</li> <li>temporary/local ID</li> <li>non-existent entity</li> </ul>"},{"location":"en/specs/gic-v1/#32-type-consistency","title":"3.2 Type Consistency","text":"<p>A relationship's <code>relationshipTypeUri</code> MUST be compatible with the types of the referenced entities. For example:</p> <p>committeeRepresentsCandidate(Committee, Candidate)</p> <p>may not be applied to:</p> <p>committeeRepresentsCandidate(School, City)</p> <p>Type compatibility follows domain vocabulary definitions.</p>"},{"location":"en/specs/gic-v1/#33-cardinality-rules","title":"3.3 Cardinality Rules","text":"<p>Each relationship type MUST specify its cardinality:</p> <ul> <li>one-to-one</li> <li>one-to-many</li> <li>many-to-many</li> </ul> <p>Adapters MUST enforce these constraints.</p>"},{"location":"en/specs/gic-v1/#34-relationship-symmetry-antisymmetry-directionality","title":"3.4 Relationship Symmetry / Antisymmetry / Directionality","text":"<p>If a relationship vocabulary declares:</p> <ul> <li>symmetric</li> <li>antisymmetric</li> <li>directional</li> <li>inverse-of</li> </ul> <p>then every instance MUST satisfy that constraint.</p> <p>Example:</p> <p>If <code>parentOf</code> is antisymmetric, we must forbid:</p> <pre><code>parentOf(A, B)\nparentOf(B, A)\n</code></pre> <p>unless <code>A = B</code> and the vocabulary allows reflexive relations.</p>"},{"location":"en/specs/gic-v1/#4-fingerprint-and-hash-integrity-constraints","title":"4. Fingerprint and Hash Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#41-deterministic-fingerprints","title":"4.1 Deterministic Fingerprints","text":"<p>Fingerprints MUST be reproducible across languages, platforms, and implementations.</p>"},{"location":"en/specs/gic-v1/#42-canonical-encoding-required","title":"4.2 Canonical Encoding Required","text":"<p>Only CEC v1 (or later explicitly declared versions) may be used to produce bytes for hashing.</p>"},{"location":"en/specs/gic-v1/#43-metadata-commitment","title":"4.3 Metadata Commitment","text":"<p>Each hash MUST commit to:</p> <ul> <li><code>cecVersion</code></li> <li><code>schemaVersion</code></li> <li><code>vocabularyVersion</code></li> <li><code>adapterVersion</code></li> <li><code>fingerprintVersion</code></li> </ul> <p>If any of these change, fingerprints may change or be non-interoperable.</p>"},{"location":"en/specs/gic-v1/#44-no-hidden-fields","title":"4.4 No Hidden Fields","text":"<p>No field outside the fingerprint structure may influence the hash.</p>"},{"location":"en/specs/gic-v1/#5-provenance-integrity-constraints","title":"5. Provenance Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#51-provenance-completeness","title":"5.1 Provenance Completeness","text":"<p>Every entity and relationship MUST retain provenance sufficient to answer:</p> <ul> <li>Who created this record?</li> <li>Which adapter(s) produced it?</li> <li>When was the transformation performed?</li> <li>What version of the schema/vocab was used?</li> </ul>"},{"location":"en/specs/gic-v1/#52-temporal-monotonicity","title":"5.2 Temporal Monotonicity","text":"<p>If an activity uses an input and generates an output:</p> <p><code>used(entity) \u2192 activity \u2192 wasGeneratedBy(entity)</code></p> <p>then:</p> <p><code>timestamp(used.input) \u2264 timestamp(activity) \u2264 timestamp(wasGeneratedBy.output)</code></p>"},{"location":"en/specs/gic-v1/#53-activity-determinism","title":"5.3 Activity Determinism","text":"<p>Provenance activities MUST reflect deterministic adapter behavior.</p> <p>No activity may claim a transformation occurred without referencing the adapter that performed it.</p>"},{"location":"en/specs/gic-v1/#6-graph-integrity-constraints","title":"6. Graph Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#61-graph-validity","title":"6.1 Graph Validity","text":"<p>A graph is valid if:</p> <ul> <li>all nodes have canonical IDs</li> <li>all edges connect existing nodes</li> <li>all payloads satisfy schema</li> <li>the graph normalizes correctly under GNS</li> </ul>"},{"location":"en/specs/gic-v1/#62-no-dangling-edges","title":"6.2 No Dangling Edges","text":"<p>Edges MUST not reference deleted or unresolvable nodes.</p>"},{"location":"en/specs/gic-v1/#63-no-cycles-in-provenance-dag","title":"6.3 No Cycles in Provenance DAG","text":"<p>Provenance graphs MUST be directed acyclic graphs.</p> <p>Cycles violate causality.</p>"},{"location":"en/specs/gic-v1/#64-idempotent-graph-normalization","title":"6.4 Idempotent Graph Normalization","text":"<p>Normalizing an already normalized graph MUST yield identical bytes.</p>"},{"location":"en/specs/gic-v1/#7-adapter-integrity-constraints","title":"7. Adapter Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#71-version-declaration","title":"7.1 Version Declaration","text":"<p>All adapters MUST emit:</p> <ul> <li><code>adapterId</code></li> <li><code>adapterVersion</code></li> </ul>"},{"location":"en/specs/gic-v1/#72-total-determinism-for-valid-inputs","title":"7.2 Total Determinism for Valid Inputs","text":"<p>Given valid input <code>x</code>:</p> <p><code>A(x) = y</code></p> <p>must always produce the same <code>y</code>.</p>"},{"location":"en/specs/gic-v1/#73-typed-partiality","title":"7.3 Typed Partiality","text":"<p>Errors MUST be explicit, typed, and reproducible.</p>"},{"location":"en/specs/gic-v1/#74-composition-rules","title":"7.4 Composition Rules","text":"<p>Adapter pipelines MUST respect adapter algebra composition and version-compatibility.</p>"},{"location":"en/specs/gic-v1/#8-cross-version-integrity-constraints","title":"8. Cross-Version Integrity Constraints","text":""},{"location":"en/specs/gic-v1/#81-version-awareness","title":"8.1 Version Awareness","text":"<p>Every CEP record MUST declare:</p> <ul> <li><code>schemaVersion</code></li> <li><code>vocabularyVersion</code></li> <li><code>adapterVersion</code></li> <li><code>cecVersion</code></li> <li><code>fingerprintVersion</code></li> <li><code>gnsVersion</code> (if graph-level)</li> </ul>"},{"location":"en/specs/gic-v1/#82-monotonic-version-evolution","title":"8.2 Monotonic Version Evolution","text":"<p>Adapters MAY target:</p> <ul> <li>the same version</li> <li>or a compatible future version</li> </ul> <p>They MUST NOT mix incompatible versions without a defined version-bridge adapter.</p>"},{"location":"en/specs/gic-v1/#83-consistency-under-updates","title":"8.3 Consistency Under Updates","text":"<p>Updating a schema or vocabulary MUST NOT retroactively break previously valid records. Backwards-compatible evolution requires:</p> <ul> <li>versioned vocabularies</li> <li>explicit deprecation</li> <li>backwards-compatible adapters</li> </ul>"},{"location":"en/specs/gic-v1/#9-summary","title":"9. Summary","text":"<p>These Global Integrity Constraints define the invariants required for CEP to be:</p> <ul> <li>deterministic</li> <li>interoperable</li> <li>identity-stable</li> <li>graph-stable</li> <li>hash-verifiable</li> <li>provenance-complete</li> </ul> <p>Any valid CEP dataset, entity, graph, or exchange MUST satisfy these constraints.</p>"},{"location":"en/specs/gns-v1/","title":"Graph Normalization Specification (GNS v1)","text":"<p>Version: 1.0.0 Status: Draft Applies to: CEP entity graphs, provenance graphs, and merged graphs Purpose: Define a deterministic normal form for CEP graphs so that equivalent graphs produce identical canonical representations and hashes.</p>"},{"location":"en/specs/gns-v1/#1-overview","title":"1. Overview","text":"<p>CEP represents civic data as graphs:</p> <ul> <li>Entity graphs: entities, relationships, and their links.  </li> <li>Provenance graphs: entities, activities, and agents (PROV-style).  </li> <li>Merged graphs: combined views over multiple sources and versions.</li> </ul> <p>The Graph Normalization Specification (GNS) defines how to:</p> <ol> <li>Represent graphs in a uniform structural model.  </li> <li>Canonically label nodes that lack global identifiers.  </li> <li>Order nodes and edges deterministically.  </li> <li>Serialize graphs via CEC v1 for hashing and verification.  </li> <li>Guarantee that semantically equivalent graphs normalize to the same form.</li> </ol> <p>GNS is versioned independently from CEC, schemas, and vocabularies.</p>"},{"location":"en/specs/gns-v1/#2-graph-model","title":"2. Graph Model","text":""},{"location":"en/specs/gns-v1/#21-nodes","title":"2.1 Nodes","text":"<p>Each node has:</p> <ul> <li><code>nodeId</code>: a string identifier (global or canonical local)  </li> <li><code>nodeType</code>: one of  </li> <li><code>entity</code> </li> <li><code>relationship</code> </li> <li><code>activity</code> </li> <li><code>agent</code> </li> <li><code>envelope</code> (optional, for packaging)  </li> <li><code>payload</code>: a CEC-compatible JSON object containing the node's attributes</li> </ul> <p>Entity nodes should carry their <code>verifiableId</code> (from EFS) in the payload.</p>"},{"location":"en/specs/gns-v1/#22-edges","title":"2.2 Edges","text":"<p>Each edge has:</p> <ul> <li><code>sourceNodeId</code> </li> <li><code>targetNodeId</code> </li> <li><code>edgeType</code>: a label (e.g., <code>used</code>, <code>wasGeneratedBy</code>, <code>wasAttributedTo</code>, <code>hasRelationship</code>, <code>participatesIn</code>, domain-specific relationship types)  </li> <li><code>edgePayload</code>: optional attributes (e.g., role labels, qualifiers)</li> </ul>"},{"location":"en/specs/gns-v1/#23-graph","title":"2.3 Graph","text":"<p>A graph <code>G</code> is:</p> <pre><code>{\n  \"graphId\": \"&lt;optional, see hashing&gt;\",\n  \"nodes\": [ ... ],\n  \"edges\": [ ... ],\n  \"graphMetadata\": {\n    \"gnsVersion\": \"1.0.0\",\n    \"cecVersion\": \"1.0.0\",\n    \"schemaVersions\": { \"...\": \"...\" },\n    \"vocabularyVersions\": { \"...\": \"...\" }\n  }\n}\n</code></pre> <p>The normalization process produces a canonical graph object of this shape.</p>"},{"location":"en/specs/gns-v1/#3-goals-of-graph-normalization","title":"3. Goals of Graph Normalization","text":"<p>GNS aims to ensure that:</p> <p>Determinism For a fixed input graph semantics and version tuple, every implementation produces the same normalized graph.</p> <p>Idempotence Normalizing an already normalized graph yields the identical graph.</p> <p>Equivalence Graphs that differ only by node-labeling or edge ordering but represent the same structure normalize to the same canonical form.</p> <p>Hash stability The normalized graph can be CEC-serialized and hashed to yield a stable graph-level CTag.</p>"},{"location":"en/specs/gns-v1/#4-node-identity-and-labeling","title":"4. Node Identity and Labeling","text":""},{"location":"en/specs/gns-v1/#41-entity-nodes","title":"4.1 Entity Nodes","text":"<p>Entity nodes have stable global identifiers.</p> <p>The payload MUST include:</p> <ul> <li><code>verifiableId</code> (from the Entity Fingerprint Specification)  </li> <li><code>entityTypeUri</code></li> </ul> <p>The <code>nodeId</code> for entity nodes MUST be set to <code>verifiableId</code>.</p> <p>No relabeling is required for entity nodes.</p>"},{"location":"en/specs/gns-v1/#42-non-entity-nodes-activities-agents-relationships-envelopes","title":"4.2 Non-Entity Nodes (Activities, Agents, Relationships, Envelopes)","text":"<p>Non-entity nodes may not have globally stable IDs. For such nodes, GNS defines a canonical local ID computed from:</p> <ul> <li>The node's type  </li> <li>A deterministic summary of its payload  </li> <li>The multiset of incident edges (types + endpoint identifiers)  </li> <li>Optional timestamps where present  </li> </ul> <p>Canonical local ID:</p> <pre><code>canonicalLocalId = \"gns:\" || base64url( H( summary(node) ) )\n</code></pre> <p>Where <code>summary(node)</code> is a CEC-serialized JSON object:</p> <ul> <li><code>nodeType</code> </li> <li><code>payload</code> (CEC-normalized)  </li> <li><code>incidentEdges</code>: a sorted list of <code>{ edgeType, direction, otherNodeId }</code></li> </ul> <p>Hash function <code>H</code> is typically SHA-256.</p> <p><code>base64url</code> is standard URL-safe Base64 encoding.</p> <p>incidentEdges sorting order:</p> <ol> <li><code>edgeType</code> </li> <li><code>direction</code> (\"in\" or \"out\")  </li> <li><code>otherNodeId</code></li> </ol>"},{"location":"en/specs/gns-v1/#43-labeling-procedure-and-fixed-point","title":"4.3 Labeling Procedure and Fixed Point","text":"<p>Because non-entity node labels depend on incident edges and incident edges depend on node labels, GNS defines a fixed-point procedure:</p> <p>Initial labeling</p> <ul> <li>Entity nodes: <code>nodeId = verifiableId</code> </li> <li>Non-entity nodes: temporary IDs (internal indices)</li> </ul> <p>Procedure</p> <ol> <li>Compute summaries for all non-entity nodes using current IDs.  </li> <li>Compute canonicalLocalId for each non-entity node.  </li> <li>Replace temporary IDs with canonicalLocalId.  </li> <li>Rebuild edges with updated sourceNodeId / targetNodeId.</li> </ol> <p>This converges in one iteration because:</p> <ul> <li>entity IDs are stable  </li> <li>each non-entity ID depends only on:</li> <li>node type  </li> <li>payload  </li> <li>incident edges with stable entity IDs and previously computed local IDs  </li> </ul> <p>Implementations MUST perform at least one full pass. A second pass MUST produce identical results (idempotence).</p>"},{"location":"en/specs/gns-v1/#5-edge-normalization","title":"5. Edge Normalization","text":"<p>After node IDs are canonical:</p> <p>For each edge:</p> <ul> <li>Ensure <code>sourceNodeId</code> and <code>targetNodeId</code> use canonical IDs.  </li> <li>Canonicalize <code>edgePayload</code> via CEP normalization + CEC.  </li> </ul> <p>Sort edges by:</p> <ol> <li><code>edgeType</code> </li> <li><code>sourceNodeId</code> </li> <li><code>targetNodeId</code> </li> <li><code>CEC(edgePayload)</code> </li> </ol> <p>If <code>edgePayload</code> is absent, treat it as <code>{}</code> for CEC.</p>"},{"location":"en/specs/gns-v1/#6-node-list-normalization","title":"6. Node List Normalization","text":"<p>After node IDs are canonical:</p> <ul> <li>Canonicalize each <code>payload</code> via CEP normalization + CEC.  </li> <li> <p>Sort nodes by:</p> </li> <li> <p><code>nodeType</code> </p> </li> <li><code>nodeId</code> </li> <li><code>CEC(payload)</code> </li> </ul>"},{"location":"en/specs/gns-v1/#7-canonical-graph-serialization","title":"7. Canonical Graph Serialization","text":"<p>Construct the graph object:</p> <pre><code>{\n  \"graphMetadata\": {\n    \"gnsVersion\": \"1.0.0\",\n    \"cecVersion\": \"&lt;cecVersion used&gt;\",\n    \"schemaVersions\": { ... },\n    \"vocabularyVersions\": { ... }\n  },\n  \"nodes\": [ ... ],\n  \"edges\": [ ... ]\n}\n</code></pre> <p>Serialize via CEC v1:</p> <ul> <li>lexicographic key ordering  </li> <li>omit <code>null</code> values  </li> <li>normalize numbers, strings, lists per CEC  </li> </ul> <p>The result is the canonical graph JSON.</p>"},{"location":"en/specs/gns-v1/#8-graph-hash-and-graph-level-ctag","title":"8. Graph Hash and Graph-Level CTag","text":"<pre><code>graphHash = H( CEC(graphObject) )\ngraphTag  = \"cep-graph:\" || base64url(graphHash)\n</code></pre> <p>Uses:</p> <ul> <li>as a <code>graphId</code> </li> <li>as a provenance reference  </li> <li>for caching and deduplication  </li> </ul>"},{"location":"en/specs/gns-v1/#9-recursion-guards-and-idempotence","title":"9. Recursion Guards and Idempotence","text":"<p>Implementations MUST ensure:</p> <ul> <li>Idempotence: normalizing a normalized graph yields identical output.  </li> <li>No recursive expansion: do not re-run canonicalization or adapters.  </li> <li>Finite behavior: normalization must terminate for all finite graphs.  </li> <li>Order of operations: all canonicalization must occur before graph normalization begins.</li> </ul>"},{"location":"en/specs/gns-v1/#10-relationship-to-other-cep-specifications","title":"10. Relationship to Other CEP Specifications","text":"<p>GNS builds upon:</p> <ul> <li>Canonical Encoding (CEC v1) </li> <li>Entity Fingerprint Specification (EFS v1) </li> <li>Adapter Algebra Specification (AAS v1) </li> </ul> <p>GNS ensures graph-level determinism and hashing; it does not redefine canonicalization or adapter semantics.</p>"},{"location":"en/specs/gns-v1/#11-versioning","title":"11. Versioning","text":"<p>Semantic versioning:</p> <ul> <li>MAJOR: breaking changes  </li> <li>MINOR: backward-compatible additions  </li> <li>PATCH: clarifications, editorial fixes  </li> </ul> <p>Every normalized graph MUST include:</p> <pre><code>\"graphMetadata\": {\n  \"gnsVersion\": \"1.0.0\",\n  ...\n}\n</code></pre>"},{"location":"en/specs/gns-v1/#12-summary","title":"12. Summary","text":"<p>GNS v1 defines:</p> <ul> <li>a uniform CEP graph model  </li> <li>canonical labeling for non-entity nodes  </li> <li>deterministic node and edge ordering  </li> <li>CEC-based canonical serialization  </li> <li>a graph-level CTag mechanism  </li> </ul> <p>These together provide a stable foundation for provenance, merges, cross-source entity graphs, and higher-level CEP reasoning.</p>"},{"location":"en/specs/vgs-v1/","title":"Versioning Governance Specification (VGS v1)","text":"<p>Version: 1.0.0</p> <p>Status: Draft</p> <p>Applies to: CEP schemas, vocabularies, adapters, fingerprints, canonical encoding, graph normalization</p> <p>Purpose: Provide a coherent and formal approach to versioning in CEP, ensuring stability, backward compatibility, and long-term reproducibility.</p>"},{"location":"en/specs/vgs-v1/#1-overview","title":"1. Overview","text":"<p>CEP consists of several interacting specifications:</p> <ul> <li>Canonical encoding (CEC)</li> <li>Entity fingerprints (EFS)</li> <li>Adapter algebra (AAS)</li> <li>Graph normalization (GNS)</li> <li>Controlled vocabularies</li> <li>Domain schemas</li> <li>Adapters</li> </ul> <p>Each of these evolves over time. Versioning Governance Specification (VGS) defines:</p> <ul> <li>how each component is versioned  </li> <li>what kinds of changes are allowed in each version class  </li> <li>how components reference one another  </li> <li>how backward compatibility is maintained  </li> <li>how verifiable IDs remain interpretable over time  </li> </ul> <p>This is essential for the long-term stability of CEP data, hashes, and interoperability.</p>"},{"location":"en/specs/vgs-v1/#vocabulary-identification","title":"Vocabulary Identification","text":"<p>Each CEP vocabulary is a JSON document identified by its <code>$id</code> field.</p> <ul> <li>The canonical URI for a vocabulary is the value of <code>$id</code>.</li> <li>All references to a vocabulary (in schemas, adapters, and documentation) MUST use this URI.</li> <li>Vocabulary documents MUST include a <code>$schema</code> field pointing to <code>cep.vocabulary.schema.json</code>.</li> <li>No additional field (such as <code>vocabularyUri</code>) is required or permitted for the canonical URI.</li> </ul> <p>Tools MAY assert that <code>$id</code> is unique within a CEP deployment and SHOULD treat the <code>$id</code> value as the stable identifier for versioning, governance, and dependency resolution.</p>"},{"location":"en/specs/vgs-v1/#2-versioning-design-principles","title":"2. Versioning Design Principles","text":"<p>CEP versioning follows five principles:</p> <ol> <li>Explicitness: Every versionable artifact declares its version using Semantic Versioning (SemVer).</li> <li>Locality: Each artifact (schema, vocab, adapter, CEC, EFS, GNS) versions independently.</li> <li>Composability: Records embed a complete version tuple so verifiers can reconstruct semantics exactly.</li> <li>Backward Compatibility: New versions must not invalidate previously valid records except via clearly documented major version changes.</li> <li>Non-Interference: Changes in descriptive metadata must not affect identity or hashes.</li> </ol>"},{"location":"en/specs/vgs-v1/#3-semantic-versioning-model","title":"3. Semantic Versioning Model","text":"<p>CEP uses Semantic Versioning (SemVer):</p> <p>MAJOR.MINOR.PATCH</p>"},{"location":"en/specs/vgs-v1/#major","title":"MAJOR","text":"<p>Breaking changes:</p> <ul> <li>identity rules change (fingerprint rules)  </li> <li>canonicalization strategy changes in a way that affects output  </li> <li>renaming or removing vocabulary terms  </li> <li>schema structural changes  </li> <li>canonical encoding (CEC) incompatibility  </li> <li>graph normalization rule changes  </li> <li>adapter output semantics change  </li> </ul> <p>MAJOR versions should be rare.</p>"},{"location":"en/specs/vgs-v1/#minor","title":"MINOR","text":"<p>Backward-compatible changes:</p> <ul> <li>new optional fields  </li> <li>new vocabulary terms (non-breaking)  </li> <li>new adapters or extended adapter behavior that preserves old semantics  </li> <li>new relationship types  </li> <li>clarifications that do not change meaning  </li> </ul>"},{"location":"en/specs/vgs-v1/#patch","title":"PATCH","text":"<p>Non-semantic fixes:</p> <ul> <li>typos  </li> <li>documentation clarifications  </li> <li>test coverage changes  </li> <li>reformatting of examples  </li> </ul> <p>Hashes must not change across patches.</p>"},{"location":"en/specs/vgs-v1/#4-versioned-components","title":"4. Versioned Components","text":"Component Version Field Independent? Notes Canonical Encoding cecVersion Yes Must be stable across ecosystems Fingerprint Rules fingerprintVersion Yes Identity-critical Graph Normalization gnsVersion Yes Affects graph-level hashes Domain Schemas schemaVersion Yes Structural constraints Controlled Vocabularies vocabularyVersion Yes Must provide deprecation paths Adapters adapterVersion Yes Reproducibility of transformations <p>Every CEP record, fingerprint, and graph must carry all applicable version tags.</p>"},{"location":"en/specs/vgs-v1/#5-version-tuples-in-records","title":"5. Version Tuples in Records","text":"<p>Each CEP object (entity, relationship, envelope, graph) must embed:</p> <pre><code>{\n  \"versions\": {\n    \"cec\": \"1.0.0\",\n    \"fingerprint\": \"1.0.0\",\n    \"schema\": \"1.0.0\",\n    \"vocabulary\": { \"...\": \"1.0.0\" },\n    \"adapter\": \"1.0.0\",\n    \"gns\": \"1.0.0\"\n  }\n}\n</code></pre> <p>This version tuple makes it possible for a verifier to:</p> <ul> <li>reconstruct canonicalization  </li> <li>rebuild the fingerprint  </li> <li>normalize the graph  </li> <li>verify relationships  </li> <li>recreate the hash  </li> </ul> <p>for any record at any time in history.</p>"},{"location":"en/specs/vgs-v1/#6-version-compatibility-rules","title":"6. Version Compatibility Rules","text":""},{"location":"en/specs/vgs-v1/#61-schema-compatibility","title":"6.1 Schema Compatibility","text":"<p>A schema version may accept records from earlier MINOR/PATCH versions. MAJOR schema changes must include a migration adapter. Backfilling or reinterpretation is forbidden \u2014 migration must be explicit.</p>"},{"location":"en/specs/vgs-v1/#62-vocabulary-compatibility","title":"6.2 Vocabulary Compatibility","text":"<p>New vocabulary terms must not break existing records. Deprecated terms must not be reused. Vocabulary upgrades must specify:</p> <ul> <li>mappings for deprecated terms  </li> <li>migration semantics if necessary  </li> </ul>"},{"location":"en/specs/vgs-v1/#63-adapter-compatibility","title":"6.3 Adapter Compatibility","text":"<p>Composition remains valid only if target and source schema versions are compatible. Adapter upgrades may alter output formats only in MINOR or MAJOR versions. No adapter may silently target a new schema version without declaring it.</p>"},{"location":"en/specs/vgs-v1/#7-versioned-provenance","title":"7. Versioned Provenance","text":"<p>Each adapter activity must record:</p> <ul> <li>adapterId  </li> <li>adapterVersion  </li> <li>schemaVersions  </li> <li>vocabularyVersions  </li> <li>timestamp  </li> <li>optional inputFingerprint  </li> </ul> <p>Provenance must be version-stable: the same pipeline version tuple must always reconstruct the same output from the same input.</p>"},{"location":"en/specs/vgs-v1/#8-effects-on-hashes-and-identity","title":"8. Effects on Hashes and Identity","text":""},{"location":"en/specs/vgs-v1/#81-hash-interpretation","title":"8.1 Hash Interpretation","text":"<p>A hash is valid only in the context of the version tuple used to generate it. A verifier must use:</p> <ul> <li>cecVersion  </li> <li>fingerprintVersion  </li> <li>schemaVersion  </li> <li>vocabularyVersion  </li> <li>adapterVersion  </li> <li>gnsVersion  </li> </ul> <p>to re-derive the canonical bytes.</p>"},{"location":"en/specs/vgs-v1/#82-identity-stability","title":"8.2 Identity Stability","text":"<p>A change to:</p> <ul> <li>vocabulary labels  </li> <li>schema descriptive fields  </li> <li>adapter metadata  </li> <li>optional attributes  </li> </ul> <p>must not affect fingerprints or verifiable IDs.</p> <p>Only MAJOR fingerprint changes may alter identities.</p>"},{"location":"en/specs/vgs-v1/#9-version-migration-requirements","title":"9. Version Migration Requirements","text":"<p>Whenever a MAJOR version increases, VGS requires:</p> <ul> <li>migration adapters  </li> <li>mapping tables (old vocabulary \u2192 new vocabulary)  </li> <li>canonicalization compatibility notes  </li> <li>hash interpretation notes  </li> </ul> <p>Records must be convertible through deterministic, auditable, versioned adapters.</p> <p>Backward compatibility is achieved through:</p> <ul> <li>version-bridge adapters  </li> <li>provenance annotations  </li> <li>dual-version compatibility modes (optional)</li> </ul>"},{"location":"en/specs/vgs-v1/#10-long-term-guarantees","title":"10. Long-Term Guarantees","text":"<p>VGS ensures that:</p> <ul> <li>A CEP record from 2030 can still be verified in 2050.  </li> <li>A hash published today remains interpretable forever.  </li> <li>New domains (campaign finance, environmental, education) remain interoperable.  </li> <li>Schema/vocabulary evolution does not undermine reproducibility.  </li> <li>Fingerprints and graph-level hashes remain stable under descriptive changes.  </li> </ul>"},{"location":"en/specs/vgs-v1/#11-summary","title":"11. Summary","text":"<p>VGS v1 defines:</p> <ul> <li>independent versioning of major CEP components  </li> <li>explicit version tuples in records  </li> <li>semantic rules for MAJOR/MINOR/PATCH  </li> <li>backward-compatibility constraints  </li> <li>migration paths for incompatible updates  </li> </ul> <p>This versioning framework ensures CEP remains a reproducible, extensible, and audit-ready civic data infrastructure.</p>"}]}